--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/local/bin/cg_annotate --diff cachegrind.out.2354510 cachegrind.out.2343563
Command 1:        ./gauss-procs-x3
Command 2:        ./gauss-procs-x2
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir__________________ 

108,615,752 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir___________________________________  file:function

<  11,900,465,225  (10956.5%, 10956.5%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs:
   11,659,592,740  (10734.7%)              gemm_f64::microkernel::fma::f64::x3x4
      122,788,514    (113.0%)              gemm_f64::microkernel::fma::f64::x1x4
       75,583,404     (69.6%)              gemm_f64::microkernel::fma::f64::x2x4
       13,267,019     (12.2%)              gemm_f64::microkernel::fma::f64::x3x3
       10,882,624     (10.0%)              pulp::x86::V3::vectorize::__impl
        8,294,730      (7.6%)              gemm_f64::microkernel::fma::f64::x3x2
        3,429,162      (3.2%)              gemm_f64::microkernel::fma::f64::x1x3
        2,136,000      (2.0%)              gemm_f64::microkernel::fma::f64::x3x1
        2,100,960      (1.9%)              gemm_f64::microkernel::fma::f64::x2x2
        1,328,722      (1.2%)              gemm_f64::microkernel::fma::f64::x1x2
          918,662      (0.8%)              gemm_f64::microkernel::fma::f64::x2x3
          142,688      (0.1%)              gemm_f64::microkernel::fma::f64::x1x1

< -11,896,716,344 (-10953.0%,     3.5%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs:
  -11,656,170,876 (-10731.6%)              gemm_f64::microkernel::fma::f64::x3x4
     -122,501,347   (-112.8%)              gemm_f64::microkernel::fma::f64::x1x4
      -75,559,135    (-69.6%)              gemm_f64::microkernel::fma::f64::x2x4
      -13,263,459    (-12.2%)              gemm_f64::microkernel::fma::f64::x3x3
      -10,882,624    (-10.0%)              pulp::x86::V3::vectorize::__impl
       -8,291,760     (-7.6%)              gemm_f64::microkernel::fma::f64::x3x2
       -3,426,552     (-3.2%)              gemm_f64::microkernel::fma::f64::x1x3
       -2,134,560     (-2.0%)              gemm_f64::microkernel::fma::f64::x3x1
       -2,098,972     (-1.9%)              gemm_f64::microkernel::fma::f64::x2x2
       -1,326,412     (-1.2%)              gemm_f64::microkernel::fma::f64::x1x2
         -918,279     (-0.8%)              gemm_f64::microkernel::fma::f64::x2x3
         -142,368     (-0.1%)              gemm_f64::microkernel::fma::f64::x1x1

<   4,049,096,770   (3727.9%,  3731.4%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs:
    3,875,198,599   (3567.8%)              gemm_f64::microkernel::fma::f64::x3x4
      121,512,744    (111.9%)              gemm_f64::microkernel::fma::f64::x1x4
       37,717,922     (34.7%)              gemm_f64::microkernel::fma::f64::x2x4
        4,419,142      (4.1%)              gemm_f64::microkernel::fma::f64::x3x3
        3,417,440      (3.1%)              gemm_f64::microkernel::fma::f64::x1x3
        2,760,950      (2.5%)              gemm_f64::microkernel::fma::f64::x3x2
        1,319,482      (1.2%)              gemm_f64::microkernel::fma::f64::x1x2
        1,053,672      (1.0%)              gemm_f64::microkernel::fma::f64::x2x2
          712,480      (0.7%)              gemm_f64::microkernel::fma::f64::x3x1
          458,182      (0.4%)              gemm_f64::microkernel::fma::f64::x2x3
          383,661      (0.4%)              pulp::x86::V3::vectorize::__impl
          142,496      (0.1%)              gemm_f64::microkernel::fma::f64::x1x1

<  -4,049,028,862  (-3727.8%,     3.5%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs:
   -3,875,202,946  (-3567.8%)              gemm_f64::microkernel::fma::f64::x3x4
     -121,512,744   (-111.9%)              gemm_f64::microkernel::fma::f64::x1x4
      -37,719,714    (-34.7%)              gemm_f64::microkernel::fma::f64::x2x4
       -4,419,535     (-4.1%)              gemm_f64::microkernel::fma::f64::x3x3
       -3,417,440     (-3.1%)              gemm_f64::microkernel::fma::f64::x1x3
       -2,760,950     (-2.5%)              gemm_f64::microkernel::fma::f64::x3x2
       -1,319,482     (-1.2%)              gemm_f64::microkernel::fma::f64::x1x2
       -1,052,776     (-1.0%)              gemm_f64::microkernel::fma::f64::x2x2
         -712,480     (-0.7%)              gemm_f64::microkernel::fma::f64::x3x1
         -458,182     (-0.4%)              gemm_f64::microkernel::fma::f64::x2x3
         -310,405     (-0.3%)              pulp::x86::V3::vectorize::__impl
         -142,208     (-0.1%)              gemm_f64::microkernel::fma::f64::x1x1

<    -541,645,242   (-498.7%,  -495.2%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs:
     -484,170,250   (-445.8%)              gemm_f64::microkernel::fma::f64::x3x4
      -30,345,254    (-27.9%)              gemm_f64::microkernel::fma::f64::x1x4
      -11,528,231    (-10.6%)              rayon_core::registry::WorkerThread::wait_until_cold
       -4,709,067     (-4.3%)              gemm_f64::microkernel::fma::f64::x2x4
       -4,200,701     (-3.9%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
       -2,035,573     (-1.9%)              pulp::x86::V3::vectorize::__impl
       -1,138,292     (-1.0%)              gemm_f64::microkernel::fma::f64::x1x3
         -734,874     (-0.7%)              gemm_f64::microkernel::fma::f64::x3x3
         -688,635     (-0.6%)              gemm_f64::microkernel::fma::f64::x3x2
         -659,694     (-0.6%)              gemm_f64::microkernel::fma::f64::x1x2
         -560,568     (-0.5%)              faer_core::solve::solve_lower_triangular_in_place_unchecked
         -354,800     (-0.3%)              gemm_f64::microkernel::fma::f64::x3x1
         -261,080     (-0.2%)              gemm_f64::microkernel::fma::f64::x2x2

<     516,397,370    (475.4%,   -19.7%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs:
      479,988,840    (441.9%)              gemm_f64::microkernel::fma::f64::x3x4
       27,807,963     (25.6%)              gemm_f64::microkernel::fma::f64::x1x4
        4,681,906      (4.3%)              gemm_f64::microkernel::fma::f64::x2x4
        1,126,462      (1.0%)              gemm_f64::microkernel::fma::f64::x1x3
          745,170      (0.7%)              gemm_f64::microkernel::fma::f64::x3x3
          688,635      (0.6%)              gemm_f64::microkernel::fma::f64::x3x2
          658,176      (0.6%)              gemm_f64::microkernel::fma::f64::x1x2
          360,560      (0.3%)              gemm_f64::microkernel::fma::f64::x3x1
          263,068      (0.2%)              gemm_f64::microkernel::fma::f64::x2x2

<     329,840,241    (303.7%,   283.9%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs:
      185,190,476    (170.5%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
       86,167,520     (79.3%)              gauss_procs::main
       23,405,864     (21.5%)              crossbeam_epoch::default::with_handle
       21,529,922     (19.8%)              faer_core::MatRef<E>::to_owned
        6,511,760      (6.0%)              rayon_core::registry::WorkerThread::wait_until_cold
        5,783,869      (5.3%)              crossbeam_deque::deque::Stealer<T>::steal
          545,104      (0.5%)              gemm_f64::gemm::f64::fma::gemm_basic
          279,433      (0.3%)              rayon_core::join::join_context::{{closure}}
          225,604      (0.2%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<    -323,089,031   (-297.5%,   -13.5%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs:
     -185,190,476   (-170.5%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
      -86,174,242    (-79.3%)              gauss_procs::main
      -22,754,010    (-20.9%)              crossbeam_epoch::default::with_handle
      -21,529,922    (-19.8%)              faer_core::MatRef<E>::to_owned
       -6,337,068     (-5.8%)              rayon_core::registry::WorkerThread::wait_until_cold
         -455,406     (-0.4%)              gemm_f64::gemm::f64::fma::gemm_basic
         -279,914     (-0.3%)              rayon_core::join::join_context::{{closure}}
         -112,802     (-0.1%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<     217,875,209    (200.6%,   187.1%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs:
      118,434,258    (109.0%)              gauss_procs::main
       35,108,796     (32.3%)              crossbeam_epoch::default::with_handle
       32,311,288     (29.7%)              faer_core::MatRef<E>::to_owned
       12,649,797     (11.6%)              rayon_core::registry::WorkerThread::wait_until_cold
        6,111,978      (5.6%)              pulp::x86::V3::vectorize::__impl
        5,781,385      (5.3%)              crossbeam_deque::deque::Stealer<T>::steal
        3,418,884      (3.1%)              gemm_f64::microkernel::fma::f64::x1x4
        1,184,174      (1.1%)              rayon_core::registry::WorkerThread::take_local_job
        1,012,500      (0.9%)              dyn_stack::DynStack::make_aligned_uninit
          564,836      (0.5%)              gemm_f64::gemm::f64::fma::gemm_basic
          465,940      (0.4%)              gemm::gemm::gemm
          216,456      (0.2%)              rayon_core::join::join_context::{{closure}}
          182,594      (0.2%)              crossbeam_epoch::internal::Global::try_advance
          134,190      (0.1%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}

<    -216,469,384   (-199.3%,   -12.2%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs:
     -118,440,820   (-109.0%)              gauss_procs::main
      -34,131,015    (-31.4%)              crossbeam_epoch::default::with_handle
      -32,317,850    (-29.8%)              faer_core::MatRef<E>::to_owned
      -12,303,375    (-11.3%)              rayon_core::registry::WorkerThread::wait_until_cold
       -6,111,978     (-5.6%)              pulp::x86::V3::vectorize::__impl
       -5,613,718     (-5.2%)              crossbeam_deque::deque::Stealer<T>::steal
       -2,589,428     (-2.4%)              gemm_f64::microkernel::fma::f64::x1x4
       -2,025,000     (-1.9%)              dyn_stack::DynStack::make_aligned_uninit
       -1,151,078     (-1.1%)              rayon_core::registry::WorkerThread::take_local_job
         -475,008     (-0.4%)              gemm_f64::gemm::f64::fma::gemm_basic
         -465,940     (-0.4%)              gemm::gemm::gemm
         -216,581     (-0.2%)              rayon_core::join::join_context::{{closure}}
         -177,354     (-0.2%)              crossbeam_epoch::internal::Global::try_advance
         -161,717     (-0.1%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}

<     212,996,942    (196.1%,   183.9%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs:
      172,186,882    (158.5%)              gauss_procs::main
       23,405,864     (21.5%)              crossbeam_epoch::default::with_handle
        7,095,024      (6.5%)              rayon_core::registry::WorkerThread::wait_until_cold
        5,778,921      (5.3%)              crossbeam_deque::deque::Stealer<T>::steal
        3,115,925      (2.9%)              pulp::x86::ArchInner::new
          650,235      (0.6%)              faer_core::mul::matmul_with_conj
          279,410      (0.3%)              rayon_core::join::join_context::{{closure}}
          214,084      (0.2%)              faer_core::join_raw::{{closure}}
          112,823      (0.1%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<    -210,607,662   (-193.9%,   -10.0%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs:
     -172,199,923   (-158.5%)              gauss_procs::main
      -22,754,010    (-20.9%)              crossbeam_epoch::default::with_handle
       -8,607,314     (-7.9%)              rayon_core::registry::WorkerThread::wait_until_cold
       -5,611,377     (-5.2%)              crossbeam_deque::deque::Stealer<T>::steal
         -743,423     (-0.7%)              faer_core::mul::matmul_with_conj
         -280,236     (-0.3%)              rayon_core::join::join_context::{{closure}}
         -145,711     (-0.1%)              faer_core::join_raw::{{closure}}
         -112,823     (-0.1%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<    -193,785,690   (-178.4%,  -188.4%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/f64.rs:
     -193,772,568   (-178.4%)              gauss_procs::main

<     193,775,849    (178.4%,   -10.0%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/f64.rs:
      193,769,288    (178.4%)              gauss_procs::main

<     130,371,135    (120.0%,   110.0%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/mod.rs:
      129,186,080    (118.9%)              gauss_procs::main
        1,172,810      (1.1%)              rayon_core::registry::WorkerThread::wait_until_cold

<    -130,344,498   (-120.0%,   -10.0%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/vec/mod.rs:
     -129,192,640   (-118.9%)              gauss_procs::main
       -1,140,100     (-1.0%)              rayon_core::registry::WorkerThread::wait_until_cold

<     104,105,499     (95.8%,    85.8%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs:
       36,500,604     (33.6%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
       30,111,477     (27.7%)              rayon_core::registry::WorkerThread::wait_until_cold
       28,851,668     (26.6%)              gemm_f64::microkernel::fma::f64::x1x4
        5,964,687      (5.5%)              pulp::x86::V3::vectorize::__impl
          527,747      (0.5%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}
          338,048      (0.3%)              gauss_procs::main
          316,636      (0.3%)              faer_cholesky::llt::compute::cholesky_in_place_impl
          232,501      (0.2%)              faer_core::mul::matmul_with_conj
          229,730      (0.2%)              faer_core::MatRef<E>::to_owned
          222,976      (0.2%)              rayon::iter::plumbing::bridge_producer_consumer::helper
          218,878      (0.2%)              rayon_core::sleep::Sleep::wake_any_threads
          178,990      (0.2%)              gemm_f64::microkernel::fma::f64::x1x2
          160,154      (0.1%)              gemm_f64::microkernel::fma::f64::x1x3

<      94,075,736     (86.6%,   172.5%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/common/thread_local/fast_local.rs:
       46,811,728     (43.1%)              crossbeam_epoch::default::with_handle
       23,688,856     (21.8%)              rayon_core::registry::WorkerThread::wait_until_cold
       23,115,564     (21.3%)              crossbeam_deque::deque::Stealer<T>::steal
          451,187      (0.4%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<     -91,468,222    (-84.2%,    88.2%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/common/thread_local/fast_local.rs:
      -45,508,020    (-41.9%)              crossbeam_epoch::default::with_handle
      -23,055,624    (-21.2%)              rayon_core::registry::WorkerThread::wait_until_cold
      -22,445,388    (-20.7%)              crossbeam_deque::deque::Stealer<T>::steal
         -451,187     (-0.4%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<     -89,398,024    (-82.3%,     5.9%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs:
      -37,826,301    (-34.8%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
      -22,333,240    (-20.6%)              gemm_f64::microkernel::fma::f64::x1x4
      -17,328,496    (-16.0%)              rayon_core::registry::WorkerThread::wait_until_cold
       -5,922,806     (-5.5%)              pulp::x86::V3::vectorize::__impl
       -3,417,517     (-3.1%)              gemm_f64::microkernel::fma::f64::x3x4
         -549,031     (-0.5%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}
         -384,022     (-0.4%)              gauss_procs::main
         -310,364     (-0.3%)              faer_cholesky::llt::compute::cholesky_in_place_impl
         -226,640     (-0.2%)              faer_core::mul::matmul_with_conj
         -226,304     (-0.2%)              rayon::iter::plumbing::bridge_producer_consumer::helper
         -223,166     (-0.2%)              faer_core::MatRef<E>::to_owned
         -209,276     (-0.2%)              rayon_core::sleep::Sleep::wake_any_threads
         -155,784     (-0.1%)              gemm_f64::microkernel::fma::f64::x1x2
         -121,873     (-0.1%)              gemm_f64::microkernel::fma::f64::x1x3

<      88,932,255     (81.9%,    87.8%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs:
       35,108,796     (32.3%)              crossbeam_epoch::default::with_handle
       20,738,122     (19.1%)              rayon_core::registry::WorkerThread::wait_until_cold
       17,349,123     (16.0%)              crossbeam_deque::deque::Stealer<T>::steal
        6,668,932      (6.1%)              crossbeam_epoch::internal::Global::try_advance
        3,115,925      (2.9%)              pulp::x86::ArchInner::new
        2,960,435      (2.7%)              rayon_core::registry::WorkerThread::take_local_job
          625,766      (0.6%)              rayon_core::sleep::Sleep::wake_specific_thread
          603,666      (0.6%)              rayon_core::join::join_context::{{closure}}
          514,777      (0.5%)              rayon_core::sleep::Sleep::sleep
          476,877      (0.4%)              std::sys::unix::locks::futex_mutex::Mutex::lock_contended
          465,650      (0.4%)              gemm_f64::gemm::f64::fma::gemm_basic
          182,878      (0.2%)              crossbeam_epoch::internal::Global::collect

<     -78,892,968    (-72.6%,    15.2%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs:
      -34,131,015    (-31.4%)              crossbeam_epoch::default::with_handle
      -20,180,627    (-18.6%)              rayon_core::registry::WorkerThread::wait_until_cold
      -11,234,519    (-10.3%)              crossbeam_deque::deque::Stealer<T>::steal
       -6,124,952     (-5.6%)              crossbeam_epoch::internal::Global::try_advance
       -2,877,695     (-2.6%)              rayon_core::registry::WorkerThread::take_local_job
       -1,490,225     (-1.4%)              pulp::x86::V3::is_available
         -604,325     (-0.6%)              rayon_core::join::join_context::{{closure}}
         -597,734     (-0.6%)              rayon_core::sleep::Sleep::wake_specific_thread
         -465,650     (-0.4%)              gemm_f64::gemm::f64::fma::gemm_basic
         -464,338     (-0.4%)              std::sys::unix::locks::futex_mutex::Mutex::lock_contended
         -422,910     (-0.4%)              rayon_core::sleep::Sleep::sleep
         -177,782     (-0.2%)              crossbeam_epoch::internal::Global::collect

<     -55,589,358    (-51.2%,   -36.0%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/gemm.rs:
      -55,658,689    (-51.2%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<     -48,686,633    (-44.8%,   -80.8%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/intrinsics.rs:
      -47,901,749    (-44.1%)              gemm_f64::microkernel::fma::f64::x3x4
         -457,824     (-0.4%)              gemm_f64::microkernel::fma::f64::x1x4
         -240,898     (-0.2%)              gemm_f64::microkernel::fma::f64::x2x4

<      48,679,988     (44.8%,   -36.0%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/intrinsics.rs:
       47,897,402     (44.1%)              gemm_f64::microkernel::fma::f64::x3x4
          454,656      (0.4%)              gemm_f64::microkernel::fma::f64::x1x4
          239,106      (0.2%)              gemm_f64::microkernel::fma::f64::x2x4

<      47,127,937     (43.4%,     7.4%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs:
       24,908,248     (22.9%)              pulp::x86::V3::vectorize::__impl
       21,526,642     (19.8%)              gauss_procs::main
          246,032      (0.2%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}
          202,448      (0.2%)              faer_cholesky::llt::compute::cholesky_in_place_impl
          136,582      (0.1%)              faer_core::mul::matmul_with_conj

<     -47,065,837    (-43.3%,   -36.0%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs:
      -24,901,686    (-22.9%)              pulp::x86::V3::vectorize::__impl
      -21,526,642    (-19.8%)              gauss_procs::main
         -246,032     (-0.2%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}
         -202,448     (-0.2%)              faer_cholesky::llt::compute::cholesky_in_place_impl
         -109,878     (-0.1%)              faer_core::mul::matvec_rowmajor::matvec_with_conj_impl

<      44,068,346     (40.6%,     4.6%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/slice/index.rs:
       43,374,883     (39.9%)              gauss_procs::main
          592,476      (0.5%)              rayon_core::sleep::Sleep::wake_specific_thread

<     -44,032,210    (-40.5%,   -35.9%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/slice/index.rs:
      -43,368,319    (-39.9%)              gauss_procs::main
         -565,290     (-0.5%)              rayon_core::sleep::Sleep::wake_specific_thread

<      43,046,748     (39.6%,     3.7%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/spec_from_iter_nested.rs:
       43,046,744     (39.6%)              gauss_procs::main

<      43,046,722     (39.6%,    43.3%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.3/src/base/iter.rs:gauss_procs::main

<      36,175,570     (33.3%,    76.7%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs:
       23,405,864     (21.5%)              crossbeam_epoch::default::with_handle
        6,514,716      (6.0%)              rayon_core::registry::WorkerThread::wait_until_cold
        5,778,901      (5.3%)              crossbeam_deque::deque::Stealer<T>::steal
          250,071      (0.2%)              rayon_core::join::join_context::{{closure}}
          225,604      (0.2%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<     -35,331,755    (-32.5%,    44.1%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs:
      -13,055,634    (-12.0%)              gemm_common::gemm::gemm_basic_generic::{{closure}}
      -11,950,200    (-11.0%)              rayon_core::registry::WorkerThread::wait_until_cold
       -2,762,927     (-2.5%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
       -2,594,379     (-2.4%)              gemm_f64::microkernel::fma::f64::x1x4
       -2,159,957     (-2.0%)              pulp::x86::V3::vectorize::__impl
       -1,367,313     (-1.3%)              gemm_f64::gemm::f64::fma::gemm_basic
         -290,768     (-0.3%)              faer_core::mul::matmul_with_conj
         -278,364     (-0.3%)              faer_core::solve::solve_lower_triangular_in_place_unchecked
         -166,341     (-0.2%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}
         -157,984     (-0.1%)              faer_core::mul::matvec_rowmajor::matvec_with_conj_impl
         -113,231     (-0.1%)              faer_core::mul::matvec_colmajor::matvec_with_conj_impl
         -109,884     (-0.1%)              faer_core::mul::inner_prod::inner_prod_with_conj

<     -35,255,575    (-32.5%,    11.7%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs:
      -15,921,401    (-14.7%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
      -10,265,592     (-9.5%)              gemm_f64::microkernel::fma::f64::x3x4
       -7,652,536     (-7.0%)              gemm_common::gemm::gemm_basic_generic::{{closure}}
         -810,000     (-0.7%)              dyn_stack::DynStack::make_aligned_uninit
         -230,496     (-0.2%)              gemm_f64::microkernel::fma::f64::x1x4
         -179,456     (-0.2%)              gemm_f64::gemm::f64::fma::gemm_basic

<      35,253,183     (32.5%,    44.1%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/thread/local.rs:
       11,844,428     (10.9%)              rayon_core::registry::WorkerThread::wait_until_cold
       11,702,932     (10.8%)              crossbeam_epoch::default::with_handle
       11,557,822     (10.6%)              crossbeam_deque::deque::Stealer<T>::steal

<     -34,275,323    (-31.6%,    12.6%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/thread/local.rs:
      -11,527,812    (-10.6%)              rayon_core::registry::WorkerThread::wait_until_cold
      -11,377,005    (-10.5%)              crossbeam_epoch::default::with_handle
      -11,222,734    (-10.3%)              crossbeam_deque::deque::Stealer<T>::steal

<      32,727,343     (30.1%,    42.7%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/internal.rs:
       28,894,505     (26.6%)              crossbeam_deque::deque::Stealer<T>::steal
        2,140,988      (2.0%)              crossbeam_epoch::default::with_handle
        1,470,656      (1.4%)              rayon_core::registry::WorkerThread::wait_until_cold
          159,432      (0.1%)              crossbeam_epoch::internal::Global::try_advance

<     -30,491,988    (-28.1%,    14.6%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-deque-0.8.3/src/deque.rs:
      -30,814,068    (-28.4%)              crossbeam_deque::deque::Stealer<T>::steal
          290,625      (0.3%)              rayon_core::registry::WorkerThread::wait_until_cold

<     -29,564,254    (-27.2%,   -12.6%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cell.rs:
      -22,754,010    (-20.9%)              crossbeam_epoch::default::with_handle
       -6,333,958     (-5.8%)              rayon_core::registry::WorkerThread::wait_until_cold
         -250,274     (-0.2%)              rayon_core::join::join_context::{{closure}}
         -225,604     (-0.2%)              gemm_common::gemm::gemm_basic_generic::{{closure}}

<      28,891,089     (26.6%,    14.0%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs:
       15,921,401     (14.7%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
        6,843,728      (6.3%)              gemm_f64::microkernel::fma::f64::x3x4
        3,798,262      (3.5%)              gemm_common::gemm::gemm_basic_generic::{{closure}}
        1,822,500      (1.7%)              dyn_stack::DynStack::make_aligned_uninit
          179,456      (0.2%)              gemm_f64::gemm::f64::fma::gemm_basic
          153,664      (0.1%)              gemm_f64::microkernel::fma::f64::x1x4

<      26,794,813     (24.7%,    38.7%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs:
       11,794,371     (10.9%)              crossbeam_epoch::default::with_handle
        8,269,614      (7.6%)              rayon_core::registry::WorkerThread::wait_until_cold
        5,778,901      (5.3%)              crossbeam_deque::deque::Stealer<T>::steal
          592,087      (0.5%)              rayon_core::registry::WorkerThread::take_local_job
          222,600      (0.2%)              rayon_core::join::join_context::{{closure}}

<      26,398,463     (24.3%,    63.0%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs:
       12,292,651     (11.3%)              rayon_core::registry::WorkerThread::wait_until_cold
        5,604,394      (5.2%)              <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize
        2,594,379      (2.4%)              gemm_f64::microkernel::fma::f64::x1x4
        2,220,247      (2.0%)              pulp::x86::V3::vectorize::__impl
        1,367,825      (1.3%)              gemm_f64::gemm::f64::fma::gemm_basic
        1,105,256      (1.0%)              gemm_common::gemm::gemm_basic_generic::{{closure}}
          290,768      (0.3%)              faer_core::mul::matmul_with_conj
          185,576      (0.2%)              faer_core::solve::solve_lower_triangular_in_place_unchecked
          170,503      (0.2%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}
          121,358      (0.1%)              faer_core::mul::matvec_rowmajor::matvec_with_conj_impl

<     -24,820,897    (-22.9%,    40.1%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs:
      -11,465,896    (-10.6%)              crossbeam_epoch::default::with_handle
       -6,912,605     (-6.4%)              rayon_core::registry::WorkerThread::wait_until_cold
       -5,611,357     (-5.2%)              crossbeam_deque::deque::Stealer<T>::steal
         -575,539     (-0.5%)              rayon_core::registry::WorkerThread::take_local_job
         -222,447     (-0.2%)              rayon_core::join::join_context::{{closure}}

<      20,840,650     (19.2%,    59.3%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs:
       11,844,830     (10.9%)              rayon_core::registry::WorkerThread::wait_until_cold
        5,778,901      (5.3%)              crossbeam_deque::deque::Stealer<T>::steal
        2,035,573      (1.9%)              pulp::x86::V3::vectorize::__impl
          506,364      (0.5%)              gemm_f64::microkernel::fma::f64::x3x4
          467,780      (0.4%)              faer_core::solve::solve_lower_triangular_in_place_unchecked

<      17,065,080     (15.7%,    75.0%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/guard.rs:
       17,331,736     (16.0%)              crossbeam_deque::deque::Stealer<T>::steal
         -266,673     (-0.2%)              crossbeam_epoch::internal::Global::try_advance

<      16,650,123     (15.3%,    90.4%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/traits/iterator.rs:
       16,650,105     (15.3%)              rayon_core::registry::WorkerThread::wait_until_cold

<     -16,184,159    (-14.9%,    75.5%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/traits/iterator.rs:
      -16,184,109    (-14.9%)              rayon_core::registry::WorkerThread::wait_until_cold

<      15,129,726     (13.9%,    89.4%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/default.rs:
       26,013,280     (23.9%)              crossbeam_epoch::default::with_handle
       -5,605,598     (-5.2%)              rayon_core::registry::WorkerThread::wait_until_cold
       -5,276,269     (-4.9%)              crossbeam_deque::deque::Stealer<T>::steal

<      14,468,101     (13.3%,   102.7%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/zip.rs:
       14,467,872     (13.3%)              pulp::x86::V3::vectorize::__impl

<     -14,453,539    (-13.3%,    89.4%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/zip.rs:
      -14,434,500    (-13.3%)              pulp::x86::V3::vectorize::__impl

<      11,947,594     (11.0%,   100.4%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/result.rs:
        5,922,214      (5.5%)              rayon_core::registry::WorkerThread::wait_until_cold
        5,778,901      (5.3%)              crossbeam_deque::deque::Stealer<T>::steal
          133,426      (0.1%)              rayon_core::sleep::Sleep::sleep

<      11,693,462     (10.8%,   111.2%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/filter.rs:rayon_core::registry::WorkerThread::wait_until_cold

<     -11,367,788    (-10.5%,   100.7%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/filter.rs:rayon_core::registry::WorkerThread::wait_until_cold

<       6,502,822      (6.0%,   106.7%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/stdarch/crates/std_detect/src/detect/cache.rs:
        6,502,801      (6.0%)              pulp::x86::ArchInner::new

<      -6,201,677     (-5.7%,   101.0%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/registry.rs:
       -5,891,954     (-5.4%)              rayon_core::registry::WorkerThread::wait_until_cold
         -417,363     (-0.4%)              rayon::iter::plumbing::bridge_producer_consumer::helper
          364,056      (0.3%)              rayon_core::registry::WorkerThread::take_local_job
         -189,227     (-0.2%)              faer_core::mul::matmul_with_conj

<      -5,287,888     (-4.9%,    96.1%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/array/mod.rs:pulp::x86::V3::vectorize::__impl

<       5,287,888      (4.9%,   101.0%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/array/mod.rs:pulp::x86::V3::vectorize::__impl

<      -4,606,171     (-4.2%,    96.7%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/stdarch/crates/std_detect/src/detect/cache.rs:
       -4,606,151     (-4.2%)              pulp::x86::V3::is_available

<       3,231,008      (3.0%,    99.7%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/locks/futex_mutex.rs:
        2,808,481      (2.6%)              std::sys::unix::locks::futex_mutex::Mutex::lock_contended
          308,666      (0.3%)              rayon_core::sleep::Sleep::wake_specific_thread
          108,996      (0.1%)              rayon_core::sleep::Sleep::sleep

<      -3,107,734     (-2.9%,    96.8%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/locks/futex_mutex.rs:
       -2,735,000     (-2.5%)              std::sys::unix::locks::futex_mutex::Mutex::lock_contended
         -294,345     (-0.3%)              rayon_core::sleep::Sleep::wake_specific_thread

<      -2,207,934     (-2.0%,    94.8%)  /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-7984a0b3eeacb87c/out/zip.rs:
       -1,827,599     (-1.7%)              pulp::x86::V3::vectorize::__impl
         -232,228     (-0.2%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}

<       2,196,808      (2.0%,    96.8%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/sync/list.rs:
        2,196,829      (2.0%)              crossbeam_epoch::internal::Global::try_advance

<       2,051,113      (1.9%,    98.7%)  /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-9690d53cf423d055/out/zip.rs:
        1,730,681      (1.6%)              pulp::x86::V3::vectorize::__impl
          251,431      (0.2%)              faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}

<       1,748,867      (1.6%,   100.3%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/thread.rs:
        1,747,075      (1.6%)              rayon_core::registry::WorkerThread::wait_until_cold

<       1,144,011      (1.1%,   101.4%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/core_arch/mod.rs:
        2,980,450      (2.7%)              pulp::x86::ArchInner::new
       -1,761,175     (-1.6%)              pulp::x86::V3::is_available

<      -1,117,659     (-1.0%,   100.4%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/thread.rs:
       -1,115,936     (-1.0%)              rayon_core::registry::WorkerThread::wait_until_cold

<        -817,648     (-0.8%,    99.6%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/mul.rs:
       -1,538,376     (-1.4%)              faer_core::mul::inner_prod::inner_prod_with_conj
          303,516      (0.3%)              faer_core::mul::matmul_with_conj
          239,436      (0.2%)              faer_core::mul::matvec_rowmajor::matvec_with_conj_impl
          214,982      (0.2%)              faer_core::mul::matvec_colmajor::matvec_with_conj_impl

<         814,797      (0.8%,   100.4%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/panicking.rs:
          691,222      (0.6%)              rayon_core::sleep::Sleep::wake_specific_thread
          117,046      (0.1%)              rayon_core::sleep::Sleep::sleep

<         758,072      (0.7%,   101.1%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/pack_operands.rs:<gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize

<        -731,298     (-0.7%,   100.4%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/panicking.rs:
         -659,505     (-0.6%)              rayon_core::sleep::Sleep::wake_specific_thread

<        -724,071     (-0.7%,    99.7%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/alloc.rs:
         -717,584     (-0.7%)              gemm_f64::gemm::f64::fma::gemm_basic

<        -679,984     (-0.6%,    99.1%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/solve.rs:
         -685,643     (-0.6%)              faer_core::solve::solve_lower_triangular_in_place_unchecked

<        -653,030     (-0.6%,    98.5%)  ./malloc/./malloc/malloc.c:
         -730,027     (-0.7%)              _int_malloc
         -203,727     (-0.2%)              unlink_chunk.constprop.0
          123,566      (0.1%)              malloc_consolidate

<         651,116      (0.6%,    99.1%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/alloc.rs:
          648,634      (0.6%)              gemm_f64::gemm::f64::fma::gemm_basic

<         589,899      (0.5%,    99.6%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/sleep/counters.rs:
          587,940      (0.5%)              rayon_core::registry::WorkerThread::wait_until_cold

<        -542,848     (-0.5%,    99.1%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sync/poison.rs:
         -471,075     (-0.4%)              rayon_core::sleep::Sleep::wake_specific_thread

<         477,665      (0.4%,    99.6%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/futex.rs:
          218,782      (0.2%)              rayon_core::sleep::Sleep::sleep
          145,013      (0.1%)              rayon_core::sleep::Sleep::wake_specific_thread

<        -462,009     (-0.4%,    99.1%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/futex.rs:
         -213,206     (-0.2%)              rayon_core::sleep::Sleep::sleep
         -140,246     (-0.1%)              rayon_core::sleep::Sleep::wake_specific_thread

<        -453,186     (-0.4%,    98.7%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/latch.rs:
         -540,018     (-0.5%)              rayon_core::registry::WorkerThread::wait_until_cold

<         448,171      (0.4%,    99.1%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sync/poison.rs:
          394,984      (0.4%)              rayon_core::sleep::Sleep::wake_specific_thread

<         421,888      (0.4%,    99.5%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs:std::sys::unix::locks::futex_mutex::Mutex::lock_contended

<        -411,809     (-0.4%,    99.1%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs:std::sys::unix::locks::futex_mutex::Mutex::lock_contended

<        -387,560     (-0.4%,    98.8%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/f64.rs:
         -387,379     (-0.4%)              pulp::x86::V3::vectorize::__impl

<         387,520      (0.4%,    99.1%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/f64.rs:
          387,379      (0.4%)              pulp::x86::V3::vectorize::__impl

<        -342,496     (-0.3%,    98.8%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/result.rs:
         -269,094     (-0.2%)              gemm_f64::gemm::f64::fma::gemm_basic

<         325,927      (0.3%,    99.1%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/epoch.rs:crossbeam_epoch::default::with_handle

<         265,179      (0.2%,    99.4%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/join/mod.rs:
          400,192      (0.4%)              rayon::iter::plumbing::bridge_producer_consumer::helper
         -181,555     (-0.2%)              rayon_core::join::join_context::{{closure}}

<         235,574      (0.2%,    99.6%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/lib.rs:
          193,836      (0.2%)              faer_core::solve::solve_lower_triangular_in_place_unchecked

<        -202,500     (-0.2%,    99.4%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/dyn-stack-0.9.0/src/lib.rs:dyn_stack::DynStack::make_aligned_uninit

<         194,133      (0.2%,    99.6%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/job.rs:
          189,695      (0.2%)              rayon_core::join::join_context::{{closure}}

<         183,941      (0.2%,    99.8%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/x86.rs:
          677,375      (0.6%)              pulp::x86::ArchInner::new
         -581,508     (-0.5%)              faer_core::solve::solve_lower_triangular_in_place_unchecked
          146,504      (0.1%)              faer_core::mul::matvec_rowmajor::matvec_with_conj_impl
          130,748      (0.1%)              faer_core::mul::matvec_colmajor::matvec_with_conj_impl
         -109,884     (-0.1%)              faer_core::mul::inner_prod::inner_prod_with_conj

<        -182,012     (-0.2%,    99.6%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/sync.rs:
         -177,782     (-0.2%)              crossbeam_epoch::default::with_handle

<         179,548      (0.2%,    99.8%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/metadata.rs:
          179,396      (0.2%)              gemm_f64::gemm::f64::fma::gemm_basic

<        -179,536     (-0.2%,    99.6%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/metadata.rs:
         -179,396     (-0.2%)              gemm_f64::gemm::f64::fma::gemm_basic

<         137,945      (0.1%,    99.7%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/tuple.rs:
          131,688      (0.1%)              rayon_core::join::join_context::{{closure}}

<        -136,422     (-0.1%,    99.6%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/tuple.rs:
         -132,244     (-0.1%)              rayon_core::join::join_context::{{closure}}

<        -133,281     (-0.1%,    99.5%)  /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/function.rs:
         -133,120     (-0.1%)              rayon::iter::plumbing::bridge_producer_consumer::helper

<         133,281      (0.1%,    99.6%)  /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/function.rs:
          133,120      (0.1%)              rayon::iter::plumbing::bridge_producer_consumer::helper

<          37,401      (0.0%,    99.6%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/sleep/mod.rs:
         -239,761     (-0.2%)              rayon_core::sleep::Sleep::sleep
          159,329      (0.1%)              rayon_core::registry::WorkerThread::wait_until_cold

<         -25,335     (-0.0%,    99.6%)  /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/lib.rs:
         -146,512     (-0.1%)              faer_core::mul::inner_prod::inner_prod_with_conj
          140,588      (0.1%)              faer_core::mul::matvec_colmajor::matvec_with_conj_impl

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir_________________________________  function:file

>      86,003,633     (79.2%,  79.2%)  gauss_procs::main:
     -193,772,568   (-178.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/f64.rs
      193,769,288    (178.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/f64.rs
     -172,199,923   (-158.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
      172,186,882    (158.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
     -129,192,640   (-118.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/vec/mod.rs
      129,186,080    (118.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/mod.rs
     -118,440,820   (-109.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
      118,434,258    (109.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
      -86,174,242    (-79.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
       86,167,520     (79.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
       43,374,883     (39.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/slice/index.rs
      -43,368,319    (-39.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/slice/index.rs
       43,046,744     (39.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/spec_from_iter_nested.rs
       43,046,722     (39.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.3/src/base/iter.rs
      -21,526,642    (-19.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs
       21,526,642     (19.8%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs
         -384,022     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
          338,048      (0.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs

>     -71,350,539    (-65.7%,  13.5%)  gemm_common::gemm::gemm_basic_generic::{{closure}}:
      -55,658,689    (-51.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/gemm.rs
      -13,055,634    (-12.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
       -7,652,536     (-7.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs
        3,798,262      (3.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs
        1,105,256      (1.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
         -451,187     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/common/thread_local/fast_local.rs
          451,187      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/common/thread_local/fast_local.rs
         -225,604     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cell.rs
          225,604      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
          225,604      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs
         -112,823     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
          112,823      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
         -112,802     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs

>      40,874,869     (37.6%,  51.1%)  crossbeam_deque::deque::Stealer<T>::steal:
      -30,814,068    (-28.4%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-deque-0.8.3/src/deque.rs
       28,894,505     (26.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/internal.rs
       23,115,564     (21.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/common/thread_local/fast_local.rs
      -22,445,388    (-20.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/common/thread_local/fast_local.rs
       17,349,123     (16.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
       17,331,736     (16.0%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/guard.rs
       11,557,822     (10.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/thread/local.rs
      -11,234,519    (-10.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
      -11,222,734    (-10.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/thread/local.rs
        5,783,869      (5.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
        5,781,385      (5.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
        5,778,921      (5.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
        5,778,901      (5.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/result.rs
        5,778,901      (5.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs
        5,778,901      (5.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs
        5,778,901      (5.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs
       -5,613,718     (-5.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
       -5,611,377     (-5.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
       -5,611,357     (-5.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs
       -5,276,269     (-4.9%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/default.rs

>      34,171,647     (31.5%,  82.6%)  crossbeam_epoch::default::with_handle:
       46,811,728     (43.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/common/thread_local/fast_local.rs
      -45,508,020    (-41.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/common/thread_local/fast_local.rs
       35,108,796     (32.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
       35,108,796     (32.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
      -34,131,015    (-31.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
      -34,131,015    (-31.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
       26,013,280     (23.9%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/default.rs
       23,405,864     (21.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
       23,405,864     (21.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
       23,405,864     (21.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs
      -22,754,010    (-20.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
      -22,754,010    (-20.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
      -22,754,010    (-20.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cell.rs
       11,794,371     (10.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs
       11,702,932     (10.8%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/thread/local.rs
      -11,465,896    (-10.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs
      -11,377,005    (-10.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/thread/local.rs
        2,140,988      (2.0%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/internal.rs
          325,927      (0.3%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/epoch.rs
         -177,782     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/sync.rs

>      16,392,476     (15.1%,  97.7%)  pulp::x86::ArchInner::new:
        6,502,801      (6.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/stdarch/crates/std_detect/src/detect/cache.rs
        3,115,925      (2.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
        3,115,925      (2.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
        2,980,450      (2.7%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/core_arch/mod.rs
          677,375      (0.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/x86.rs

>      13,343,005     (12.3%, 110.0%)  rayon_core::registry::WorkerThread::wait_until_cold:
       30,111,477     (27.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
       23,688,856     (21.8%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/common/thread_local/fast_local.rs
      -23,055,624    (-21.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/common/thread_local/fast_local.rs
       20,738,122     (19.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
      -20,180,627    (-18.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
      -17,328,496    (-16.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
       16,650,105     (15.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/traits/iterator.rs
      -16,184,109    (-14.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/traits/iterator.rs
       12,649,797     (11.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
      -12,303,375    (-11.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
       12,292,651     (11.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
      -11,950,200    (-11.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
       11,844,830     (10.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs
       11,844,428     (10.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/thread/local.rs
       11,693,462     (10.8%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/filter.rs
      -11,528,231    (-10.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
      -11,527,812    (-10.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/thread/local.rs
      -11,367,788    (-10.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/filter.rs
       -8,607,314     (-7.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
        8,269,614      (7.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs
        7,095,024      (6.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
       -6,912,605     (-6.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs
        6,514,716      (6.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs
        6,511,760      (6.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
       -6,337,068     (-5.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
       -6,333,958     (-5.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cell.rs
        5,922,214      (5.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/result.rs
       -5,891,954     (-5.4%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/registry.rs
       -5,605,598     (-5.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/default.rs
        1,747,075      (1.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/thread.rs
        1,470,656      (1.4%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/internal.rs
        1,172,810      (1.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/mod.rs
       -1,140,100     (-1.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/vec/mod.rs
       -1,115,936     (-1.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/thread.rs
          587,940      (0.5%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/sleep/counters.rs
         -540,018     (-0.5%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/latch.rs
          290,625      (0.3%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-deque-0.8.3/src/deque.rs
          159,329      (0.1%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/sleep/mod.rs

>      -7,857,551     (-7.2%, 102.7%)  pulp::x86::V3::is_available:
       -4,606,151     (-4.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/stdarch/crates/std_detect/src/detect/cache.rs
       -1,761,175     (-1.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/core_arch/mod.rs
       -1,490,225     (-1.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs

>      -7,101,257     (-6.5%,  96.2%)  gemm_f64::microkernel::fma::f64::x3x4:
   11,659,592,740  (10734.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
  -11,656,170,876 (-10731.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
   -3,875,202,946  (-3567.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
    3,875,198,599   (3567.8%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
     -484,170,250   (-445.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
      479,988,840    (441.9%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
      -47,901,749    (-44.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/intrinsics.rs
       47,897,402     (44.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/intrinsics.rs
      -10,265,592     (-9.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs
        6,843,728      (6.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs
       -3,417,517     (-3.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
          506,364      (0.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs

>       5,027,996      (4.6%, 100.8%)  gemm_f64::microkernel::fma::f64::x1x4:
      122,788,514    (113.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
     -122,501,347   (-112.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
     -121,512,744   (-111.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
      121,512,744    (111.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
      -30,345,254    (-27.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
       28,851,668     (26.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
       27,807,963     (25.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
      -22,333,240    (-20.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
        3,418,884      (3.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
       -2,594,379     (-2.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
        2,594,379      (2.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
       -2,589,428     (-2.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
         -457,824     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/intrinsics.rs
          454,656      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/intrinsics.rs
         -230,496     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs
          153,664      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs

>       2,742,288      (2.5%, 103.3%)  crossbeam_epoch::internal::Global::try_advance:
        6,668,932      (6.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
       -6,124,952     (-5.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
        2,196,829      (2.0%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/sync/list.rs
         -266,673     (-0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/guard.rs
          182,594      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
         -177,354     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
          159,432      (0.1%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/internal.rs

>      -1,926,859     (-1.8%, 101.6%)  <gemm_common::simd::x86::Fma as gemm_common::simd::Simd>::vectorize:
     -185,190,476   (-170.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
      185,190,476    (170.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
      -37,826,301    (-34.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
       36,500,604     (33.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
      -15,921,401    (-14.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs
       15,921,401     (14.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs
        5,604,394      (5.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
       -4,200,701     (-3.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
       -2,762,927     (-2.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
          758,072      (0.7%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/pack_operands.rs

>      -1,904,656     (-1.8%,  99.8%)  faer_core::mul::inner_prod::inner_prod_with_conj:
       -1,538,376     (-1.4%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/mul.rs
         -146,512     (-0.1%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/lib.rs
         -109,884     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
         -109,884     (-0.1%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/x86.rs

>      -1,408,572     (-1.3%,  98.5%)  faer_core::solve::solve_lower_triangular_in_place_unchecked:
         -685,643     (-0.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/solve.rs
         -581,508     (-0.5%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/x86.rs
         -560,568     (-0.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
          467,780      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs
         -278,364     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
          193,836      (0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/lib.rs
          185,576      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs

>        -730,027     (-0.7%,  97.8%)  _int_malloc:./malloc/./malloc/malloc.c

>         584,789      (0.5%,  98.4%)  faer_core::mul::matvec_colmajor::matvec_with_conj_impl:
          214,982      (0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/mul.rs
          140,588      (0.1%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/lib.rs
          130,748      (0.1%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/x86.rs
         -113,231     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs

>         529,536      (0.5%,  98.9%)  rayon_core::registry::WorkerThread::take_local_job:
        2,960,435      (2.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
       -2,877,695     (-2.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
        1,184,174      (1.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
       -1,151,078     (-1.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
          592,087      (0.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs
         -575,539     (-0.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs
          364,056      (0.3%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/registry.rs

>         465,752      (0.4%,  99.3%)  faer_core::mul::matvec_rowmajor::matvec_with_conj_impl:
          239,436      (0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/mul.rs
         -157,984     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
          146,504      (0.1%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/x86.rs
          121,358      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
         -109,878     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs

>         211,804      (0.2%,  99.5%)  faer_core::mul::matmul_with_conj:
         -743,423     (-0.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
          650,235      (0.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
          303,516      (0.3%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/mul.rs
         -290,768     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
          290,768      (0.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
          232,501      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
         -226,640     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
         -189,227     (-0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/registry.rs
          136,582      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs

>         206,551      (0.2%,  99.7%)  rayon_core::sleep::Sleep::wake_specific_thread:
          691,222      (0.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/panicking.rs
         -659,505     (-0.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/panicking.rs
          625,766      (0.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
         -597,734     (-0.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
          592,476      (0.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/slice/index.rs
         -565,290     (-0.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/slice/index.rs
         -471,075     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sync/poison.rs
          394,984      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sync/poison.rs
          308,666      (0.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/locks/futex_mutex.rs
         -294,345     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/locks/futex_mutex.rs
          145,013      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/futex.rs
         -140,246     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/futex.rs

>        -203,727     (-0.2%,  99.5%)  unlink_chunk.constprop.0:./malloc/./malloc/malloc.c

>        -202,500     (-0.2%,  99.3%)  dyn_stack::DynStack::make_aligned_uninit:
       -2,025,000     (-1.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
        1,822,500      (1.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs
        1,012,500      (0.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
         -810,000     (-0.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs
         -202,500     (-0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/dyn-stack-0.9.0/src/lib.rs

>         123,566      (0.1%,  99.4%)  malloc_consolidate:./malloc/./malloc/malloc.c

>         103,828      (0.1%,  99.5%)  std::sys::unix::locks::futex_mutex::Mutex::lock_contended:
        2,808,481      (2.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/locks/futex_mutex.rs
       -2,735,000     (-2.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/locks/futex_mutex.rs
          476,877      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
         -464,338     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
          421,888      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs
         -411,809     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs

>          78,988      (0.1%,  99.6%)  crossbeam_epoch::internal::Global::collect:
          182,878      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
         -177,782     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs

>          53,521      (0.0%,  99.6%)  faer_core::join_raw::{{closure}}:
          214,084      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
         -145,711     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs

>          53,282      (0.0%,  99.7%)  rayon_core::sleep::Sleep::wake_any_threads:
          218,878      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
         -209,276     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs

>         -51,294     (-0.0%,  99.6%)  gemm_f64::microkernel::fma::f64::x2x4:
       75,583,404     (69.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
      -75,559,135    (-69.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
      -37,719,714    (-34.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
       37,717,922     (34.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
       -4,709,067     (-4.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
        4,681,906      (4.3%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
         -240,898     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/intrinsics.rs
          239,106      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/intrinsics.rs

>         -48,718     (-0.0%,  99.6%)  rayon::iter::plumbing::bridge_producer_consumer::helper:
         -417,363     (-0.4%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/registry.rs
          400,192      (0.4%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/join/mod.rs
         -226,304     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
          222,976      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
         -133,120     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/function.rs
          133,120      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/function.rs

>          40,881      (0.0%,  99.6%)  rayon_core::sleep::Sleep::sleep:
          514,777      (0.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
         -422,910     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
         -239,761     (-0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/sleep/mod.rs
          218,782      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/futex.rs
         -213,206     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/futex.rs
          133,426      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/result.rs
          117,046      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/panicking.rs
          108,996      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/locks/futex_mutex.rs

>          32,086      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x1x3:
        3,429,162      (3.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -3,426,552     (-3.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -3,417,440     (-3.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
        3,417,440      (3.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
       -1,138,292     (-1.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
        1,126,462      (1.0%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
          160,154      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
         -121,873     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs

>         -29,608     (-0.0%,  99.6%)  faer_core::mul::triangular::mat_x_mat_into_lower_impl_unchecked::{{closure}}:
         -549,031     (-0.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
          527,747      (0.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
          251,431      (0.2%)            /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-9690d53cf423d055/out/zip.rs
         -246,032     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs
          246,032      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs
         -232,228     (-0.2%)            /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-7984a0b3eeacb87c/out/zip.rs
          170,503      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
         -166,341     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
         -161,717     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
          134,190      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs

>          27,464      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x1x2:
        1,328,722      (1.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -1,326,412     (-1.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -1,319,482     (-1.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
        1,319,482      (1.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
         -659,694     (-0.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
          658,176      (0.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
          178,990      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
         -155,784     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs

>          25,655      (0.0%,  99.7%)  pulp::x86::V3::vectorize::__impl:
       24,908,248     (22.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs
      -24,901,686    (-22.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs
       14,467,872     (13.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/zip.rs
      -14,434,500    (-13.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/zip.rs
      -10,882,624    (-10.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       10,882,624     (10.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -6,111,978     (-5.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
        6,111,978      (5.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
        5,964,687      (5.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
       -5,922,806     (-5.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
       -5,287,888     (-4.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/array/mod.rs
        5,287,888      (4.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/array/mod.rs
        2,220,247      (2.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
       -2,159,957     (-2.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
       -2,035,573     (-1.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
        2,035,573      (1.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs
       -1,827,599     (-1.7%)            /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-7984a0b3eeacb87c/out/zip.rs
        1,730,681      (1.6%)            /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-9690d53cf423d055/out/zip.rs
         -387,379     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/f64.rs
          387,379      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/f64.rs
          383,661      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
         -310,405     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs

>          22,816      (0.0%,  99.7%)  gemm_f64::gemm::f64::fma::gemm_basic:
        1,367,825      (1.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
       -1,367,313     (-1.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
         -717,584     (-0.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/alloc.rs
          648,634      (0.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/alloc.rs
          564,836      (0.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
          545,104      (0.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
         -475,008     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
         -465,650     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
          465,650      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
         -455,406     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
         -269,094     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/result.rs
         -179,456     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs
          179,456      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs
         -179,396     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/metadata.rs
          179,396      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/metadata.rs

>          10,287      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x3x3:
       13,267,019     (12.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
      -13,263,459    (-12.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -4,419,535     (-4.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
        4,419,142      (4.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
          745,170      (0.7%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
         -734,874     (-0.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs

>           9,661      (0.0%,  99.7%)  faer_cholesky::llt::compute::cholesky_in_place_impl:
          316,636      (0.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
         -310,364     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
         -202,448     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs
          202,448      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs

>           7,200      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x3x1:
        2,136,000      (2.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -2,134,560     (-2.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
         -712,480     (-0.7%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
          712,480      (0.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
          360,560      (0.3%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
         -354,800     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs

>          -6,562     (-0.0%,  99.7%)  faer_core::MatRef<E>::to_owned:
      -32,317,850    (-29.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
       32,311,288     (29.7%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
      -21,529,922    (-19.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
       21,529,922     (19.8%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
          229,730      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
         -223,166     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs

>           5,940      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x3x2:
        8,294,730      (7.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -8,291,760     (-7.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -2,760,950     (-2.5%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
        2,760,950      (2.5%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
         -688,635     (-0.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
          688,635      (0.6%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs

>           5,068      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x2x2:
        2,100,960      (1.9%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
       -2,098,972     (-1.9%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
        1,053,672      (1.0%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
       -1,052,776     (-1.0%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
          263,068      (0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
         -261,080     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs

>           4,944      (0.0%,  99.7%)  rayon_core::join::join_context::{{closure}}:
         -604,325     (-0.6%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
          603,666      (0.6%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
         -280,236     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
         -279,914     (-0.3%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
          279,433      (0.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
          279,410      (0.3%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
         -250,274     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cell.rs
          250,071      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs
          222,600      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs
         -222,447     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs
         -216,581     (-0.2%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
          216,456      (0.2%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
          189,695      (0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/job.rs
         -181,555     (-0.2%)            /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/join/mod.rs
         -132,244     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/tuple.rs
          131,688      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/tuple.rs

>           2,140      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x1x1:
          142,688      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
          142,496      (0.1%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
         -142,368     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
         -142,208     (-0.1%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs

>           1,149      (0.0%,  99.7%)  gemm_f64::microkernel::fma::f64::x2x3:
          918,662      (0.8%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
         -918,279     (-0.8%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
         -458,182     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
          458,182      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs

>               0      (0.0%,  99.7%)  gemm::gemm::gemm:
         -465,940     (-0.4%)            /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
          465,940      (0.4%)            /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-deque-0.8.3/src/deque.rs
--------------------------------------------------------------------------------
Ir__________________ 

-11,612,639 (-10.7%)  <unknown (line 0)>

-- line 49 ----------------------------------------
          .                   drop(Vec::from_raw_parts(self.ptr, 0, self.cap));
          .               }
          .           
          .               /// Returns a pointer to the task at the specified `index`.
          .               unsafe fn at(&self, index: isize) -> *mut T {
          .                   // `self.cap` is always a power of two.
          .                   // We do all the loads at `MaybeUninit` because we might realize, after loading, that we
          .                   // don't actually have the right to access this memory.
        274   (0.0%)          self.ptr.offset(index & (self.cap - 1) as isize)
          .               }
          .           
          .               /// Writes `task` into the specified `index`.
          .               ///
          .               /// This method might be concurrently called with another `read` at the same index, which is
          .               /// technically speaking a data race and therefore UB. We should use an atomic store here, but
          .               /// that would be more expensive and difficult to implement generically for all types `T`.
          .               /// Hence, as a hack, we use a volatile write instead.
-- line 65 ----------------------------------------
-- line 208 ----------------------------------------
          .               ///
          .               /// # Examples
          .               ///
          .               /// ```
          .               /// use crossbeam_deque::Worker;
          .               ///
          .               /// let w = Worker::<i32>::new_fifo();
          .               /// ```
        -40  (-0.0%)      pub fn new_fifo() -> Worker<T> {
          .                   let buffer = Buffer::alloc(MIN_CAP);
          .           
          .                   let inner = Arc::new(CachePadded::new(Inner {
          .                       front: AtomicIsize::new(0),
          .                       back: AtomicIsize::new(0),
          .                       buffer: CachePadded::new(Atomic::new(buffer)),
          .                   }));
          .           
          0                   Worker {
          .                       inner,
          .                       buffer: Cell::new(buffer),
          .                       flavor: Flavor::Fifo,
          .                       _marker: PhantomData,
          .                   }
          0               }
          .           
          .               /// Creates a LIFO worker queue.
          .               ///
          .               /// Tasks are pushed and popped from the same end.
          .               ///
          .               /// # Examples
          .               ///
          .               /// ```
-- line 239 ----------------------------------------
-- line 245 ----------------------------------------
          .                   let buffer = Buffer::alloc(MIN_CAP);
          .           
          .                   let inner = Arc::new(CachePadded::new(Inner {
          .                       front: AtomicIsize::new(0),
          .                       back: AtomicIsize::new(0),
          .                       buffer: CachePadded::new(Atomic::new(buffer)),
          .                   }));
          .           
         40   (0.0%)          Worker {
          .                       inner,
          .                       buffer: Cell::new(buffer),
          .                       flavor: Flavor::Lifo,
          .                       _marker: PhantomData,
          .                   }
          .               }
          .           
          .               /// Creates a stealer for this queue.
-- line 261 ----------------------------------------
-- line 267 ----------------------------------------
          .               /// ```
          .               /// use crossbeam_deque::Worker;
          .               ///
          .               /// let w = Worker::<i32>::new_lifo();
          .               /// let s = w.stealer();
          .               /// ```
          .               pub fn stealer(&self) -> Stealer<T> {
          .                   Stealer {
         20   (0.0%)              inner: self.inner.clone(),
          0                       flavor: self.flavor,
          .                   }
          .               }
          .           
          .               /// Resizes the internal buffer to the new capacity of `new_cap`.
          .               #[cold]
          .               unsafe fn resize(&self, new_cap: usize) {
          .                   // Load the back index, front index, and buffer.
          .                   let b = self.inner.back.load(Ordering::Relaxed);
-- line 284 ----------------------------------------
-- line 349 ----------------------------------------
          .               ///
          .               /// assert!(w.is_empty());
          .               /// w.push(1);
          .               /// assert!(!w.is_empty());
          .               /// ```
          .               pub fn is_empty(&self) -> bool {
          .                   let b = self.inner.back.load(Ordering::Relaxed);
          .                   let f = self.inner.front.load(Ordering::SeqCst);
        243   (0.0%)          b.wrapping_sub(f) <= 0
          .               }
          .           
          .               /// Returns the number of tasks in the deque.
          .               ///
          .               /// ```
          .               /// use crossbeam_deque::Worker;
          .               ///
          .               /// let w = Worker::new_lifo();
-- line 365 ----------------------------------------
-- line 392 ----------------------------------------
          .                   let b = self.inner.back.load(Ordering::Relaxed);
          .                   let f = self.inner.front.load(Ordering::Acquire);
          .                   let mut buffer = self.buffer.get();
          .           
          .                   // Calculate the length of the queue.
          .                   let len = b.wrapping_sub(f);
          .           
          .                   // Is the queue full?
          0                   if len >= buffer.cap as isize {
          .                       // Yes. Grow the underlying buffer.
          .                       unsafe {
          .                           self.resize(2 * buffer.cap);
          .                       }
          .                       buffer = self.buffer.get();
          .                   }
          .           
          .                   // Write `task` into the slot.
-- line 408 ----------------------------------------
-- line 438 ----------------------------------------
          .                   // Load the back and front index.
          .                   let b = self.inner.back.load(Ordering::Relaxed);
          .                   let f = self.inner.front.load(Ordering::Relaxed);
          .           
          .                   // Calculate the length of the queue.
          .                   let len = b.wrapping_sub(f);
          .           
          .                   // Is the queue empty?
     32,968   (0.0%)          if len <= 0 {
          .                       return None;
          .                   }
          .           
       -278  (-0.0%)          match self.flavor {
          .                       // Pop from the front of the queue.
          .                       Flavor::Fifo => {
          .                           // Try incrementing the front index to pop the task.
          .                           let f = self.inner.front.fetch_add(1, Ordering::SeqCst);
          .                           let new_f = f.wrapping_add(1);
          .           
          .                           if b.wrapping_sub(new_f) < 0 {
          .                               self.inner.front.store(f, Ordering::Relaxed);
-- line 458 ----------------------------------------
-- line 482 ----------------------------------------
          .                           atomic::fence(Ordering::SeqCst);
          .           
          .                           // Load the front index.
          .                           let f = self.inner.front.load(Ordering::Relaxed);
          .           
          .                           // Compute the length after the back index was decremented.
          .                           let len = b.wrapping_sub(f);
          .           
       -417  (-0.0%)                  if len < 0 {
          .                               // The queue is empty. Restore the back index to the original task.
          .                               self.inner.back.store(b.wrapping_add(1), Ordering::Relaxed);
          .                               None
          .                           } else {
          .                               // Read the task to be popped.
          .                               let buffer = self.buffer.get();
          .                               let mut task = unsafe { Some(buffer.read(b)) };
          .           
          .                               // Are we popping the last task from the queue?
       -278  (-0.0%)                      if len == 0 {
          .                                   // Try incrementing the front index.
          .                                   if self
          .                                       .inner
          .                                       .front
          .                                       .compare_exchange(
          .                                           f,
          .                                           f.wrapping_add(1),
          .                                           Ordering::SeqCst,
-- line 508 ----------------------------------------
-- line 513 ----------------------------------------
          .                                       // Failed. We didn't pop anything. Reset to `None`.
          .                                       task.take();
          .                                   }
          .           
          .                                   // Restore the back index to the original task.
          .                                   self.inner.back.store(b.wrapping_add(1), Ordering::Relaxed);
          .                               } else {
          .                                   // Shrink the buffer if `len` is less than one fourth of the capacity.
     -1,680  (-0.0%)                          if buffer.cap > MIN_CAP && len < buffer.cap as isize / 4 {
          .                                       unsafe {
          .                                           self.resize(buffer.cap / 2);
          .                                       }
          .                                   }
          .                               }
          .           
          .                               task.map(|t| unsafe { t.assume_init() })
          .                           }
-- line 529 ----------------------------------------
-- line 581 ----------------------------------------
          .               /// assert!(s.is_empty());
          .               /// w.push(1);
          .               /// assert!(!s.is_empty());
          .               /// ```
          .               pub fn is_empty(&self) -> bool {
          .                   let f = self.inner.front.load(Ordering::Acquire);
          .                   atomic::fence(Ordering::SeqCst);
          .                   let b = self.inner.back.load(Ordering::Acquire);
        423   (0.0%)          b.wrapping_sub(f) <= 0
          .               }
          .           
          .               /// Returns the number of tasks in the deque.
          .               ///
          .               /// ```
          .               /// use crossbeam_deque::Worker;
          .               ///
          .               /// let w = Worker::new_lifo();
-- line 597 ----------------------------------------
-- line 620 ----------------------------------------
          .               /// let w = Worker::new_lifo();
          .               /// w.push(1);
          .               /// w.push(2);
          .               ///
          .               /// let s = w.stealer();
          .               /// assert_eq!(s.steal(), Steal::Success(1));
          .               /// assert_eq!(s.steal(), Steal::Success(2));
          .               /// ```
 18,006,879  (16.6%)      pub fn steal(&self) -> Steal<T> {
          .                   // Load the front index.
          .                   let f = self.inner.front.load(Ordering::Acquire);
          .           
          .                   // A SeqCst fence is needed here.
          .                   //
          .                   // If the current thread is already pinned (reentrantly), we must manually issue the
          .                   // fence. Otherwise, the following pinning will issue the fence anyway, so we don't
          .                   // have to.
    325,927   (0.3%)          if epoch::is_pinned() {
          .                       atomic::fence(Ordering::SeqCst);
          .                   }
          .           
          .                   let guard = &epoch::pin();
          .           
          .                   // Load the back index.
          .                   let b = self.inner.back.load(Ordering::Acquire);
          .           
          .                   // Is the queue empty?
    651,854   (0.6%)          if b.wrapping_sub(f) <= 0 {
          .                       return Steal::Empty;
          .                   }
          .           
          .                   // Load the buffer and read the task at the front.
          .                   let buffer = self.inner.buffer.load(Ordering::Acquire, guard);
          .                   let task = unsafe { buffer.deref().read(f) };
          .           
          .                   // Try incrementing the front index to steal the task.
          .                   // If the buffer has been swapped or the increment fails, we retry.
     -3,285  (-0.0%)          if self.inner.buffer.load(Ordering::Acquire, guard) != buffer
      3,561   (0.0%)              || self
          .                           .inner
          .                           .front
          .                           .compare_exchange(f, f.wrapping_add(1), Ordering::SeqCst, Ordering::Relaxed)
          .                           .is_err()
          .                   {
          .                       // We didn't steal this task, forget it.
          .                       return Steal::Retry;
          .                   }
          .           
          .                   // Return the stolen task.
        366   (0.0%)          Steal::Success(unsafe { task.assume_init() })
-38,106,691 (-35.1%)      }
          .           
          .               /// Steals a batch of tasks and pushes them into another worker.
          .               ///
          .               /// How many tasks exactly will be stolen is not specified. That said, this method will try to
          .               /// steal around half of the tasks in the queue, but also not more than some constant limit.
          .               ///
          .               /// # Examples
          .               ///
-- line 678 ----------------------------------------
-- line 1202 ----------------------------------------
          .               const UNINIT: Self = Self {
          .                   task: UnsafeCell::new(MaybeUninit::uninit()),
          .                   state: AtomicUsize::new(0),
          .               };
          .           
          .               /// Waits until a task is written into the slot.
          .               fn wait_write(&self) {
          .                   let backoff = Backoff::new();
          0                   while self.state.load(Ordering::Acquire) & WRITE == 0 {
          .                       backoff.snooze();
          .                   }
          .               }
          .           }
          .           
          .           /// A block in a linked list.
          .           ///
          .           /// Each block in the list can hold up to `BLOCK_CAP` values.
-- line 1218 ----------------------------------------
-- line 1222 ----------------------------------------
          .           
          .               /// Slots for values.
          .               slots: [Slot<T>; BLOCK_CAP],
          .           }
          .           
          .           impl<T> Block<T> {
          .               /// Creates an empty block that starts at `start_index`.
          .               fn new() -> Block<T> {
          7   (0.0%)          Self {
          .                       next: AtomicPtr::new(ptr::null_mut()),
          .                       slots: [Slot::UNINIT; BLOCK_CAP],
          .                   }
          .               }
          .           
          .               /// Waits until the next pointer is set.
          .               fn wait_next(&self) -> *mut Block<T> {
          .                   let backoff = Backoff::new();
          .                   loop {
          .                       let next = self.next.load(Ordering::Acquire);
          7   (0.0%)              if !next.is_null() {
          .                           return next;
          .                       }
          .                       backoff.snooze();
          .                   }
          .               }
          .           
          .               /// Sets the `DESTROY` bit in slots starting from `start` and destroys the block.
          .               unsafe fn destroy(this: *mut Block<T>, count: usize) {
          .                   // It is not necessary to set the `DESTROY` bit in the last slot because that slot has
          .                   // begun destruction of the block.
          .                   for i in (0..count).rev() {
          .                       let slot = (*this).slots.get_unchecked(i);
          .           
          .                       // Mark the `DESTROY` bit if a thread is still using the slot.
       -434  (-0.0%)              if slot.state.load(Ordering::Acquire) & READ == 0
          .                           && slot.state.fetch_or(DESTROY, Ordering::AcqRel) & READ == 0
          .                       {
          .                           // If a thread is still using the slot, it will continue destruction of the block.
          .                           return;
          .                       }
          .                   }
          .           
          .                   // No thread is using the block, now it is safe to destroy it.
-- line 1264 ----------------------------------------
-- line 1352 ----------------------------------------
          .               pub fn push(&self, task: T) {
          .                   let backoff = Backoff::new();
          .                   let mut tail = self.tail.index.load(Ordering::Acquire);
          .                   let mut block = self.tail.block.load(Ordering::Acquire);
          .                   let mut next_block = None;
          .           
          .                   loop {
          .                       // Calculate the offset of the index into the block.
          0                       let offset = (tail >> SHIFT) % LAP;
          .           
          .                       // If we reached the end of the block, wait until the next one is installed.
          0                       if offset == BLOCK_CAP {
          .                           backoff.snooze();
          .                           tail = self.tail.index.load(Ordering::Acquire);
          .                           block = self.tail.block.load(Ordering::Acquire);
          .                           continue;
          .                       }
          .           
          .                       // If we're going to have to install the next block, allocate it in advance in order to
          .                       // make the wait for other threads as short as possible.
          0                       if offset + 1 == BLOCK_CAP && next_block.is_none() {
          .                           next_block = Some(Box::new(Block::<T>::new()));
          .                       }
          .           
          0                       let new_tail = tail + (1 << SHIFT);
          .           
          .                       // Try advancing the tail forward.
          0                       match self.tail.index.compare_exchange_weak(
          .                           tail,
          .                           new_tail,
          .                           Ordering::SeqCst,
          .                           Ordering::Acquire,
          .                       ) {
          .                           Ok(_) => unsafe {
          .                               // If we've reached the end of the block, install the next one.
          0                               if offset + 1 == BLOCK_CAP {
          .                                   let next_block = Box::into_raw(next_block.unwrap());
          .                                   let next_index = new_tail.wrapping_add(1 << SHIFT);
          .           
          .                                   self.tail.block.store(next_block, Ordering::Release);
          .                                   self.tail.index.store(next_index, Ordering::Release);
          .                                   (*block).next.store(next_block, Ordering::Release);
          .                               }
          .           
-- line 1395 ----------------------------------------
-- line 1430 ----------------------------------------
          .                   let mut offset;
          .           
          .                   let backoff = Backoff::new();
          .                   loop {
          .                       head = self.head.index.load(Ordering::Acquire);
          .                       block = self.head.block.load(Ordering::Acquire);
          .           
          .                       // Calculate the offset of the index into the block.
     64,864   (0.1%)              offset = (head >> SHIFT) % LAP;
          .           
          .                       // If we reached the end of the block, wait until the next one is installed.
     32,432   (0.0%)              if offset == BLOCK_CAP {
          .                           backoff.snooze();
          .                       } else {
          .                           break;
          .                       }
          .                   }
          .           
     16,216   (0.0%)          let mut new_head = head + (1 << SHIFT);
          .           
     32,432   (0.0%)          if new_head & HAS_NEXT == 0 {
          .                       atomic::fence(Ordering::SeqCst);
          .                       let tail = self.tail.index.load(Ordering::Relaxed);
          .           
          .                       // If the tail equals the head, that means the queue is empty.
     64,864   (0.1%)              if head >> SHIFT == tail >> SHIFT {
          .                           return Steal::Empty;
          .                       }
          .           
          .                       // If head and tail are not in the same block, set `HAS_NEXT` in head.
          0                       if (head >> SHIFT) / LAP != (tail >> SHIFT) / LAP {
          .                           new_head |= HAS_NEXT;
          .                       }
          .                   }
          .           
          .                   // Try moving the head index forward.
          0                   if self
          .                       .head
          .                       .index
          .                       .compare_exchange_weak(head, new_head, Ordering::SeqCst, Ordering::Acquire)
          .                       .is_err()
          .                   {
          .                       return Steal::Retry;
          .                   }
          .           
          .                   unsafe {
          .                       // If we've reached the end of the block, move to the next one.
          0                       if offset + 1 == BLOCK_CAP {
          .                           let next = (*block).wait_next();
          0                           let mut next_index = (new_head & !HAS_NEXT).wrapping_add(1 << SHIFT);
         21   (0.0%)                  if !(*next).next.load(Ordering::Relaxed).is_null() {
          .                               next_index |= HAS_NEXT;
          .                           }
          .           
          .                           self.head.block.store(next, Ordering::Release);
          .                           self.head.index.store(next_index, Ordering::Release);
          .                       }
          .           
          .                       // Read the task.
          .                       let slot = (*block).slots.get_unchecked(offset);
          .                       slot.wait_write();
          .                       let task = slot.task.get().read().assume_init();
          .           
          .                       // Destroy the block if we've reached the end, or if another thread wanted to destroy
          .                       // but couldn't because we were busy reading from the slot.
     -1,458  (-0.0%)              if (offset + 1 == BLOCK_CAP)
        972   (0.0%)                  || (slot.state.fetch_or(READ, Ordering::AcqRel) & DESTROY != 0)
          .                       {
          .                           Block::destroy(block, offset);
          .                       }
          .           
          .                       Steal::Success(task)
          .                   }
          .               }
          .           
-- line 1504 ----------------------------------------
-- line 1913 ----------------------------------------
          .               ///
          .               /// assert!(q.is_empty());
          .               /// q.push(1);
          .               /// assert!(!q.is_empty());
          .               /// ```
          .               pub fn is_empty(&self) -> bool {
          .                   let head = self.head.index.load(Ordering::SeqCst);
          .                   let tail = self.tail.index.load(Ordering::SeqCst);
        842   (0.0%)          head >> SHIFT == tail >> SHIFT
          .               }
          .           
          .               /// Returns the number of tasks in the queue.
          .               ///
          .               /// # Examples
          .               ///
          .               /// ```
          .               /// use crossbeam_deque::Injector;
-- line 1929 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/default.rs
--------------------------------------------------------------------------------
Ir__________________ 

-11,377,005 (-10.5%)  <unknown (line 0)>

-- line 26 ----------------------------------------
          .                       static ref COLLECTOR: Collector = Collector::new();
          .                   }
          .                   &COLLECTOR
          .               }
          .           }
          .           
          .           thread_local! {
          .               /// The per-thread participant for the default garbage collector.
        -20  (-0.0%)      static HANDLE: LocalHandle = collector().register();
          .           }
          .           
          .           /// Pins the current thread.
          .           #[inline]
          .           pub fn pin() -> Guard {
    493,471   (0.5%)      with_handle(|handle| handle.pin())
          .           }
          .           
          .           /// Returns `true` if the current thread is pinned.
          .           #[inline]
          .           pub fn is_pinned() -> bool {
          .               with_handle(|handle| handle.is_pinned())
          .           }
          .           
          .           /// Returns the default global collector.
          .           pub fn default_collector() -> &'static Collector {
          .               collector()
          .           }
          .           
          .           #[inline]
 24,383,645  (22.4%)  fn with_handle<F, R>(mut f: F) -> R
          .           where
          .               F: FnMut(&LocalHandle) -> R,
          .           {
          .               HANDLE
          .                   .try_with(|h| f(h))
          .                   .unwrap_or_else(|_| f(&collector().register()))
  1,629,635   (1.5%)  }
          .           
          .           #[cfg(all(test, not(crossbeam_loom)))]
          .           mod tests {
          .               use crossbeam_utils::thread;
          .           
          .               #[test]
          .               fn pin_while_exiting() {
          .                   struct Foo;
-- line 70 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/epoch.rs
--------------------------------------------------------------------------------
Ir____________ 

-- line 43 ----------------------------------------
      .             pub(crate) fn is_pinned(self) -> bool {
      .                 (self.data & 1) == 1
      .             }
      .         
      .             /// Returns the same epoch, but marked as pinned.
      .             #[inline]
      .             pub(crate) fn pinned(self) -> Epoch {
      .                 Epoch {
325,927 (0.3%)              data: self.data | 1,
      .                 }
      .             }
      .         
      .             /// Returns the same epoch, but marked as unpinned.
      .             #[inline]
      .             pub(crate) fn unpinned(self) -> Epoch {
      .                 Epoch {
      .                     data: self.data & !1,
-- line 59 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/guard.rs
--------------------------------------------------------------------------------
Ir________________ 

11,375,053 (10.5%)  <unknown (line 0)>

-- line 186 ----------------------------------------
         .              ///     }
         .              /// }
         .              /// # unsafe { drop(a.into_owned()); } // avoid leak
         .              /// ```
         .              pub unsafe fn defer_unchecked<F, R>(&self, f: F)
         .              where
         .                  F: FnOnce() -> R,
         .              {
   -88,891 (-0.1%)          if let Some(local) = self.local.as_ref() {
         .                      local.defer(Deferred::new(move || drop(f())), self);
         .                  } else {
         .                      drop(f());
         .                  }
         .              }
         .          
         .              /// Stores a destructor for an object so that it can be deallocated and dropped at some point
         .              /// after all currently pinned threads get unpinned.
-- line 202 ----------------------------------------
-- line 403 ----------------------------------------
         .              pub fn collector(&self) -> Option<&Collector> {
         .                  unsafe { self.local.as_ref().map(|local| local.collector()) }
         .              }
         .          }
         .          
         .          impl Drop for Guard {
         .              #[inline]
         .              fn drop(&mut self) {
 5,778,918  (5.3%)          if let Some(local) = unsafe { self.local.as_ref() } {
         .                      local.unpin();
         .                  }
         .              }
         .          }
         .          
         .          impl fmt::Debug for Guard {
         .              fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         .                  f.pad("Guard { .. }")
-- line 419 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/internal.rs
--------------------------------------------------------------------------------
Ir________________ 

   461,998  (0.4%)  <unknown (line 0)>

-- line 103 ----------------------------------------
         .              /// Seals the bag with the given epoch.
         .              fn seal(self, epoch: Epoch) -> SealedBag {
         .                  SealedBag { epoch, _bag: self }
         .              }
         .          }
         .          
         .          impl Default for Bag {
         .              fn default() -> Self {
         0                  Bag {
         .                      len: 0,
         .                      deferreds: [Deferred::NO_OP; MAX_OBJECTS],
         .                  }
         .              }
         .          }
         .          
         .          impl Drop for Bag {
         .              fn drop(&mut self) {
-- line 119 ----------------------------------------
-- line 193 ----------------------------------------
         .              /// Collects several bags from the global queue and executes deferred functions in them.
         .              ///
         .              /// Note: This may itself produce garbage and in turn allocate new bags.
         .              ///
         .              /// `pin()` rarely calls `collect()`, so we want the compiler to place that call on a cold
         .              /// path. In other words, we want the compiler to optimize branching for the case when
         .              /// `collect()` is not called.
         .              #[cold]
    28,028  (0.0%)      pub(crate) fn collect(&self, guard: &Guard) {
    12,740  (0.0%)          let global_epoch = self.try_advance(guard);
         .          
         .                  let steps = if cfg!(crossbeam_sanitize) {
         .                      usize::max_value()
         .                  } else {
         .                      Self::COLLECT_STEPS
         .                  };
         .          
         .                  for _ in 0..steps {
-- line 210 ----------------------------------------
-- line 211 ----------------------------------------
         .                      match self.queue.try_pop_if(
         .                          &|sealed_bag: &SealedBag| sealed_bag.is_expired(global_epoch),
         .                          guard,
         .                      ) {
         .                          None => break,
         .                          Some(sealed_bag) => drop(sealed_bag),
         .                      }
         .                  }
    20,384  (0.0%)      }
         .          
         .              /// Attempts to advance the global epoch.
         .              ///
         .              /// The global epoch can advance only if all currently pinned participants have been pinned in
         .              /// the current epoch.
         .              ///
         .              /// Returns the current global epoch.
         .              ///
         .              /// `try_advance()` is annotated `#[cold]` because it is rarely called.
         .              #[cold]
    17,836  (0.0%)      pub(crate) fn try_advance(&self, guard: &Guard) -> Epoch {
         .                  let global_epoch = self.epoch.load(Ordering::Relaxed);
         .                  atomic::fence(Ordering::SeqCst);
         .          
         .                  // TODO(stjepang): `Local`s are stored in a linked list because linked lists are fairly
         .                  // easy to implement in a lock-free manner. However, traversal can be slow due to cache
         .                  // misses and data dependencies. We should experiment with other data structures as well.
     2,548  (0.0%)          for local in self.locals.iter(guard) {
         .                      match local {
         .                          Err(IterError::Stalled) => {
         .                              // A concurrent thread stalled this iteration. That thread might also try to
         .                              // advance the epoch, in which case we leave the job to it. Otherwise, the
         .                              // epoch will not be advanced.
         .                              return global_epoch;
         .                          }
         .                          Ok(local) => {
         .                              let local_epoch = local.epoch.load(Ordering::Relaxed);
         .          
         .                              // If the participant was pinned in a different epoch, we cannot advance the
         .                              // global epoch just yet.
    19,428  (0.0%)                      if local_epoch.is_pinned() && local_epoch.unpinned() != global_epoch {
         .                                  return global_epoch;
         .                              }
         .                          }
         .                      }
         .                  }
         .                  atomic::fence(Ordering::Acquire);
         .          
         .                  // All pinned participants were pinned in the current global epoch.
-- line 258 ----------------------------------------
-- line 260 ----------------------------------------
         .                  //
         .                  // Note that if another thread already advanced it before us, this store will simply
         .                  // overwrite the global epoch with the same value. This is true because `try_advance` was
         .                  // called from a thread that was pinned in `global_epoch`, and the global epoch cannot be
         .                  // advanced two steps ahead of it.
         .                  let new_epoch = global_epoch.successor();
         .                  self.epoch.store(new_epoch, Ordering::Release);
         .                  new_epoch
    20,384  (0.0%)      }
         .          }
         .          
         .          /// Participant for garbage collection.
         .          pub(crate) struct Local {
         .              /// A node in the intrusive linked list of `Local`s.
         .              entry: Entry,
         .          
         .              /// The local epoch.
-- line 276 ----------------------------------------
-- line 313 ----------------------------------------
         .              /// global queue.
         .              const PINNINGS_BETWEEN_COLLECT: usize = 128;
         .          
         .              /// Registers a new `Local` in the provided `Global`.
         .              pub(crate) fn register(collector: &Collector) -> LocalHandle {
         .                  unsafe {
         .                      // Since we dereference no pointers in this block, it is safe to use `unprotected`.
         .          
      -160 (-0.0%)              let local = Owned::new(Local {
         .                          entry: Entry::default(),
         .                          epoch: AtomicEpoch::new(Epoch::starting()),
         .                          collector: UnsafeCell::new(ManuallyDrop::new(collector.clone())),
         .                          bag: UnsafeCell::new(Bag::new()),
         .                          guard_count: Cell::new(0),
         .                          handle_count: Cell::new(1),
         .                          pin_count: Cell::new(Wrapping(0)),
         .                      })
-- line 329 ----------------------------------------
-- line 375 ----------------------------------------
         .                  }
         .          
         .                  self.global().collect(guard);
         .              }
         .          
         .              /// Pins the `Local`.
         .              #[inline]
         .              pub(crate) fn pin(&self) -> Guard {
   325,927  (0.3%)          let guard = Guard { local: self };
         .          
         .                  let guard_count = self.guard_count.get();
         .                  self.guard_count.set(guard_count.checked_add(1).unwrap());
         .          
   651,854  (0.6%)          if guard_count == 0 {
         .                      let global_epoch = self.global().epoch.load(Ordering::Relaxed);
         .                      let new_epoch = global_epoch.pinned();
         .          
         .                      // Now we must store `new_epoch` into `self.epoch` and execute a `SeqCst` fence.
         .                      // The fence makes sure that any future loads from `Atomic`s will not happen before
         .                      // this store.
         .                      if cfg!(all(
         .                          any(target_arch = "x86", target_arch = "x86_64"),
-- line 396 ----------------------------------------
-- line 427 ----------------------------------------
         .                      }
         .          
         .                      // Increment the pin counter.
         .                      let count = self.pin_count.get();
         .                      self.pin_count.set(count + Wrapping(1));
         .          
         .                      // After every `PINNINGS_BETWEEN_COLLECT` try advancing the epoch and collecting
         .                      // some garbage.
   651,854  (0.6%)              if count.0 % Self::PINNINGS_BETWEEN_COLLECT == 0 {
   185,426  (0.2%)                  self.global().collect(&guard);
         .                      }
         .                  }
         .          
   325,927  (0.3%)          guard
         .              }
         .          
         .              /// Unpins the `Local`.
         .              #[inline]
         .              pub(crate) fn unpin(&self) {
         .                  let guard_count = self.guard_count.get();
 5,937,284  (5.5%)          self.guard_count.set(guard_count - 1);
         .          
11,874,568 (10.9%)          if guard_count == 1 {
         .                      self.epoch.store(Epoch::starting(), Ordering::Release);
         .          
12,191,317 (11.2%)              if self.handle_count.get() == 0 {
         .                          self.finalize();
         .                      }
         .                  }
         .              }
         .          
         .              /// Unpins and then pins the `Local`.
         .              #[inline]
         .              pub(crate) fn repin(&self) {
-- line 460 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-epoch-0.9.15/src/sync/list.rs
--------------------------------------------------------------------------------
Ir_______________ 

1,930,269  (1.8%)  <unknown (line 0)>

-- line 148 ----------------------------------------
        .              pub(crate) unsafe fn delete(&self, guard: &Guard) {
        .                  self.next.fetch_or(1, Release, guard);
        .              }
        .          }
        .          
        .          impl<T, C: IsElement<T>> List<T, C> {
        .              /// Returns a new, empty linked list.
        .              pub(crate) fn new() -> Self {
       -1 (-0.0%)          Self {
        .                      head: Atomic::null(),
        .                      _marker: PhantomData,
        .                  }
        .              }
        .          
        .              /// Inserts `entry` into the head of the list.
        .              ///
        .              /// # Safety
-- line 164 ----------------------------------------
-- line 178 ----------------------------------------
        .                  let entry_ptr = Shared::from(entry as *const _);
        .                  // Read the current successor of where we want to insert.
        .                  let mut next = to.load(Relaxed, guard);
        .          
        .                  loop {
        .                      // Set the Entry of the to-be-inserted element to point to the previous successor of
        .                      // `to`.
        .                      entry.next.store(next, Relaxed);
      -20 (-0.0%)              match to.compare_exchange_weak(next, entry_ptr, Release, Relaxed, guard) {
        .                          Ok(_) => break,
        .                          // We lost the race or weak CAS failed spuriously. Update the successor and try
        .                          // again.
        .                          Err(err) => next = err.current,
        .                      }
        .                  }
        .              }
        .          
-- line 194 ----------------------------------------
-- line 231 ----------------------------------------
        .                  }
        .              }
        .          }
        .          
        .          impl<'g, T: 'g, C: IsElement<T>> Iterator for Iter<'g, T, C> {
        .              type Item = Result<&'g T, IterError>;
        .          
        .              fn next(&mut self) -> Option<Self::Item> {
  163,080  (0.2%)          while let Some(c) = unsafe { self.curr.as_ref() } {
        .                      let succ = c.next.load(Acquire, self.guard);
        .          
  103,480  (0.1%)              if succ.tag() == 1 {
        .                          // This entry was removed. Try unlinking it from the list.
        .                          let succ = succ.with_tag(0);
        .          
        .                          // The tag should always be zero, because removing a node after a logically deleted
        .                          // node leaves the list in an invalid state.
        .                          debug_assert!(self.curr.tag() == 0);
        .          
        .                          // Try to unlink `curr` from the list, and get the new value of `self.pred`.
-- line 250 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/dyn-stack-0.9.0/src/lib.rs
--------------------------------------------------------------------------------
Ir______________ 

       0          <unknown (line 0)>

-- line 286 ----------------------------------------
       .              assert!(
       .                  (align & (align.wrapping_sub(1))) == 0,
       .                  r#"
       .          requested alignment is not a power of two:
       .           - requested alignment: {}
       .          "#,
       .                  align
       .              );
-202,500 (-0.2%)      assert!(
 202,500  (0.2%)          alignof_val <= align,
       .                  r#"
       .          requested alignment is less than the minimum valid alignment for `{}`:
       .           - requested alignment: {}
       .           - minimum alignment: {}
       .          "#,
       .                  type_name,
       .                  align,
       .                  alignof_val,
       .              );
       .          }
       .          
       .          #[track_caller]
       .          #[inline]
       .          fn check_enough_space_for_align_offset(len: usize, align: usize, align_offset: usize) {
-202,500 (-0.2%)      assert!(
 202,500  (0.2%)          len >= align_offset,
       .                  r#"
       .          buffer is not large enough to accomodate the requested alignment
       .           - buffer length: {}
       .           - requested alignment: {}
       .           - byte offset for alignment: {}
       .          "#,
       .                  align,
       .                  align_offset,
-- line 319 ----------------------------------------
-- line 327 ----------------------------------------
       .              remaining_len: usize,
       .              sizeof_val: usize,
       .              array_len: usize,
       .              type_name: &'static str,
       .          ) {
       .              if sizeof_val == 0 {
       .                  return;
       .              }
-202,500 (-0.2%)      assert!(
 202,500  (0.2%)          remaining_len / sizeof_val >= array_len,
       .                  r#"
       .          buffer is not large enough to allocate an array of type `{}` of the requested length:
       .           - remaining buffer length (after adjusting for alignment): {},
       .           - requested array length: {} ({} bytes),
       .          "#,
       .                  type_name,
       .                  remaining_len,
       .                  array_len,
-- line 344 ----------------------------------------
-- line 387 ----------------------------------------
       .                  alignof_val: usize,
       .                  type_name: &'static str,
       .              ) -> (&'out mut [MaybeUninit<u8>], &'out mut [MaybeUninit<u8>]) {
       .                  let len = buffer.len();
       .                  let align_offset = buffer.as_mut_ptr().align_offset(align);
       .          
       .                  check_alignment(align, alignof_val, type_name);
       .                  check_enough_space_for_align_offset(len, align, align_offset);
-202,500 (-0.2%)          check_enough_space_for_array(len - align_offset, sizeof_val, size, type_name);
       .          
       .                  let buffer = unsafe { buffer.get_unchecked_mut(align_offset..) };
       .                  let len = len - align_offset;
       .          
       .                  let begin = buffer.as_mut_ptr();
       0                  let begin_len = size * sizeof_val;
       .                  let mid = unsafe { begin.add(begin_len) };
       0                  let mid_len = len - begin_len;
       .                  unsafe {
       .                      (
       .                          core::slice::from_raw_parts_mut(begin, begin_len),
       .                          core::slice::from_raw_parts_mut(mid, mid_len),
       .                      )
       .                  }
       .              }
       .          
-- line 411 ----------------------------------------
-- line 413 ----------------------------------------
       .              /// buffer.
       .              ///
       .              /// # Panics
       .              ///
       .              /// Panics if the stack isn't large enough to allocate the array.
       .              #[track_caller]
       .              #[inline]
       .              #[must_use]
       0              pub fn make_aligned_uninit<T>(
       .                  self,
       .                  size: usize,
       .                  align: usize,
       .              ) -> (DynArray<'a, MaybeUninit<T>>, Self) {
       .                  let (taken, remaining) = Self::split_buffer(
       .                      self.buffer,
       .                      size,
       .                      align,
-- line 429 ----------------------------------------
-- line 431 ----------------------------------------
       .                      core::mem::align_of::<T>(),
       .                      core::any::type_name::<T>(),
       .                  );
       .          
       .                  let (len, ptr) = {
       .                      let taken = unsafe { transmute_slice::<MaybeUninit<T>>(taken, size) };
       .                      (taken.len(), taken.as_mut_ptr())
       .                  };
       0                  (
       .                      DynArray {
       .                          ptr: unsafe { NonNull::<MaybeUninit<T>>::new_unchecked(ptr) },
       .                          len,
       .                          _marker: (PhantomData, PhantomData),
       .                      },
       .                      DynStack::new(remaining),
       .                  )
       0              }
       .          
       .              /// Returns a new aligned [`DynArray`], initialized with the provided function, and a stack
       .              /// over the remainder of the buffer.
       .              ///
       .              /// # Panics
       .              ///
       .              /// Panics if the stack isn't large enough to allocate the array, or if the provided function
       .              /// panics.
-- line 455 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/lib.rs
--------------------------------------------------------------------------------
Ir______________ 

 -39,195 (-0.0%)  <unknown (line 0)>

-- line 745 ----------------------------------------
       .          }
       .          impl<E: Entity<Group<()> = (), Unit = E>> SimpleEntity for E {}
       .          
       .          const _: () = {
       .              const fn __assert_simple_entity<E: SimpleEntity>() {}
       .              __assert_simple_entity::<f32>();
       .          };
       .          
       2  (0.0%)  #[derive(Copy, Clone, Debug, PartialEq, Eq)]
       .          pub enum Conj {
       .              Yes,
       .              No,
       .          }
       .          
       .          impl Conj {
       .              #[inline]
       .              pub fn compose(self, other: Conj) -> Conj {
-- line 761 ----------------------------------------
-- line 3678 ----------------------------------------
       .              __marker: PhantomData<&'a mut E>,
       .          }
       .          
       .          impl<'a, E: Entity> IntoConst for MatMut<'a, E> {
       .              type Target = MatRef<'a, E>;
       .          
       .              #[inline(always)]
       .              fn into_const(self) -> Self::Target {
       0                  MatRef {
       .                      inner: self.inner,
       .                      __marker: PhantomData,
       .                  }
       .              }
       .          }
       .          
       .          impl<'short, 'a, E: Entity> Reborrow<'short> for MatMut<'a, E> {
       .              type Target = MatRef<'short, E>;
       .          
       .              #[inline(always)]
       .              fn rb(&'short self) -> Self::Target {
       0                  MatRef {
       .                      inner: self.inner,
       .                      __marker: PhantomData,
       .                  }
       .              }
       .          }
       .          
       .          impl<'short, 'a, E: Entity> ReborrowMut<'short> for MatMut<'a, E> {
       .              type Target = MatMut<'short, E>;
       .          
       .              #[inline(always)]
       .              fn rb_mut(&'short mut self) -> Self::Target {
-185,864 (-0.2%)          MatMut {
       .                      inner: self.inner,
       .                      __marker: PhantomData,
       .                  }
       .              }
       .          }
       .          
       .          impl<'a, E: Entity> IntoConst for MatRef<'a, E> {
       .              type Target = MatRef<'a, E>;
-- line 3718 ----------------------------------------
-- line 4126 ----------------------------------------
       .              #[track_caller]
       .              pub unsafe fn from_raw_parts(
       .                  ptr: E::Group<*const E::Unit>,
       .                  nrows: usize,
       .                  ncols: usize,
       .                  row_stride: isize,
       .                  col_stride: isize,
       .              ) -> Self {
      18  (0.0%)          Self {
       .                      inner: MatImpl {
       .                          ptr: E::into_copy(E::map(ptr, |ptr| ptr as *mut E::Unit)),
       .                          nrows,
       .                          ncols,
       .                          row_stride,
       .                          col_stride,
       .                      },
       .                      __marker: PhantomData,
-- line 4142 ----------------------------------------
-- line 4147 ----------------------------------------
       .              #[inline(always)]
       .              pub fn as_ptr(self) -> E::Group<*const E::Unit> {
       .                  E::map(E::from_copy(self.inner.ptr), |ptr| ptr as *const E::Unit)
       .              }
       .          
       .              /// Returns the number of rows of the matrix.
       .              #[inline(always)]
       .              pub fn nrows(&self) -> usize {
 195,183  (0.2%)          self.inner.nrows
       .              }
       .          
       .              /// Returns the number of columns of the matrix.
       .              #[inline(always)]
       .              pub fn ncols(&self) -> usize {
 -73,255 (-0.1%)          self.inner.ncols
       .              }
       .          
       .              /// Returns the row stride of the matrix, specified in number of elements, not in bytes.
       .              #[inline(always)]
       .              pub fn row_stride(&self) -> isize {
       0                  self.inner.row_stride
       .              }
       .          
       .              /// Returns the column stride of the matrix, specified in number of elements, not in bytes.
       .              #[inline(always)]
       .              pub fn col_stride(&self) -> isize {
       0                  self.inner.col_stride
       .              }
       .          
       .              /// Returns raw pointers to the element at the given indices.
       .              #[inline(always)]
       .              pub fn ptr_at(self, row: usize, col: usize) -> E::Group<*const E::Unit> {
       .                  E::map(self.as_ptr(), |ptr| {
  92,788  (0.1%)              ptr.wrapping_offset(row as isize * self.inner.row_stride)
  33,917  (0.0%)                  .wrapping_offset(col as isize * self.inner.col_stride)
       .                  })
       .              }
       .          
       .              /// Returns raw pointers to the element at the given indices, assuming the provided indices
       .              /// are within the matrix dimensions.
       .              ///
       .              /// # Safety
       .              /// The behavior is undefined if any of the following conditions are violated:
-- line 4189 ----------------------------------------
-- line 4190 ----------------------------------------
       .              /// * `row < self.nrows()`.
       .              /// * `col < self.ncols()`.
       .              #[inline(always)]
       .              #[track_caller]
       .              pub unsafe fn ptr_inbounds_at(self, row: usize, col: usize) -> E::Group<*const E::Unit> {
       .                  debug_assert!(row < self.nrows());
       .                  debug_assert!(col < self.ncols());
       .                  E::map(self.as_ptr(), |ptr| {
  73,252  (0.1%)              ptr.offset(row as isize * self.inner.row_stride)
       0                          .offset(col as isize * self.inner.col_stride)
       .                  })
       .              }
       .          
       .              /// Splits the matrix horizontally and vertically at the given indices into four corners and
       .              /// returns an array of each submatrix, in the following order:
       .              /// * top left.
       .              /// * top right.
       .              /// * bottom left.
-- line 4207 ----------------------------------------
-- line 4209 ----------------------------------------
       .              ///
       .              /// # Panics
       .              /// The function panics if any of the following conditions are violated:
       .              /// * `row <= self.nrows()`.
       .              /// * `col <= self.ncols()`.
       .              #[inline(always)]
       .              #[track_caller]
       .              pub fn split_at(self, row: usize, col: usize) -> [Self; 4] {
  -1,445 (-0.0%)          assert!(row <= self.nrows());
       0                  assert!(col <= self.ncols());
       .          
       .                  let row_stride = self.row_stride();
       .                  let col_stride = self.col_stride();
       .          
       .                  let nrows = self.nrows();
       .                  let ncols = self.ncols();
       .          
       .                  unsafe {
-- line 4226 ----------------------------------------
-- line 4228 ----------------------------------------
       .                      let top_right = self.ptr_at(0, col);
       .                      let bot_left = self.ptr_at(row, 0);
       .                      let bot_right = self.ptr_at(row, col);
       .          
       .                      [
       .                          Self::from_raw_parts(top_left, row, col, row_stride, col_stride),
       .                          Self::from_raw_parts(top_right, row, ncols - col, row_stride, col_stride),
       .                          Self::from_raw_parts(bot_left, nrows - row, col, row_stride, col_stride),
       0                          Self::from_raw_parts(bot_right, nrows - row, ncols - col, row_stride, col_stride),
       .                      ]
       .                  }
       .              }
       .          
       .              /// Splits the matrix horizontally at the given row into two parts and returns an array of each
       .              /// submatrix, in the following order:
       .              /// * top.
       .              /// * bottom.
-- line 4244 ----------------------------------------
-- line 4312 ----------------------------------------
       .              ///
       .              /// # Safety
       .              /// The behavior is undefined if any of the following conditions are violated:
       .              /// * `row < self.nrows()`.
       .              /// * `col < self.ncols()`.
       .              #[inline(always)]
       .              #[track_caller]
       .              pub unsafe fn read_unchecked(&self, row: usize, col: usize) -> E {
       0                  E::from_units(E::map(self.get_unchecked(row, col), |ptr| (*ptr).clone()))
       .              }
       .          
       .              /// Reads the value of the element at the given indices, with bound checks.
       .              ///
       .              /// # Panics
       .              /// The function panics if any of the following conditions are violated:
       .              /// * `row < self.nrows()`.
       .              /// * `col < self.ncols()`.
       .              #[inline(always)]
       .              #[track_caller]
       .              pub fn read(&self, row: usize, col: usize) -> E {
 -33,917 (-0.0%)          E::from_units(E::map(self.get(row, col), |ptr| (*ptr).clone()))
       .              }
       .          
       .              /// Returns a view over the transpose of `self`.
       .              ///
       .              /// # Example
       .              /// ```
       .              /// use faer_core::mat;
       .              ///
-- line 4340 ----------------------------------------
-- line 4343 ----------------------------------------
       .              /// let transpose = view.transpose();
       .              ///
       .              /// let expected = mat![[1.0, 4.0], [2.0, 5.0], [3.0, 6.0]];
       .              /// assert_eq!(expected.as_ref(), transpose);
       .              /// ```
       .              #[inline(always)]
       .              #[must_use]
       .              pub fn transpose(self) -> Self {
-219,757 (-0.2%)          Self {
       .                      inner: MatImpl {
       .                          ptr: self.inner.ptr,
       .                          nrows: self.inner.ncols,
       .                          ncols: self.inner.nrows,
       .                          row_stride: self.inner.col_stride,
       .                          col_stride: self.inner.row_stride,
       .                      },
       .                      __marker: PhantomData,
-- line 4359 ----------------------------------------
-- line 4365 ----------------------------------------
       .              #[must_use]
       .              pub fn conjugate(self) -> MatRef<'a, E::Conj>
       .              where
       .                  E: Conjugate,
       .              {
       .                  unsafe {
       .                      // SAFETY: Conjugate requires that E::Unit and E::Conj::Unit have the same layout
       .                      // and that E::GroupCopy<X> == E::Conj::GroupCopy<X>
       0                      MatRef {
       .                          inner: MatImpl {
       .                              ptr: transmute_unchecked::<
       .                                  E::GroupCopy<*mut E::Unit>,
       .                                  <E::Conj as Entity>::GroupCopy<*mut <E::Conj as Entity>::Unit>,
       .                              >(self.inner.ptr),
       .                              nrows: self.inner.nrows,
       .                              ncols: self.inner.ncols,
       .                              row_stride: self.inner.row_stride,
-- line 4381 ----------------------------------------
-- line 4407 ----------------------------------------
       .                          // SAFETY: see Self::conjugate
       .                          MatRef {
       .                              inner: MatImpl {
       .                                  ptr: transmute_unchecked::<
       .                                      E::GroupCopy<*mut E::Unit>,
       .                                      <E::Canonical as Entity>::GroupCopy<
       .                                          *mut <E::Canonical as Entity>::Unit,
       .                                      >,
     576  (0.0%)                          >(self.inner.ptr),
     576  (0.0%)                          nrows: self.inner.nrows,
     576  (0.0%)                          ncols: self.inner.ncols,
     288  (0.0%)                          row_stride: self.inner.row_stride,
     288  (0.0%)                          col_stride: self.inner.col_stride,
       .                              },
       .                              __marker: PhantomData,
       .                          }
       .                      },
       .                      if coe::is_same::<E, E::Canonical>() {
       .                          Conj::No
       .                      } else {
       .                          Conj::Yes
-- line 4427 ----------------------------------------
-- line 4442 ----------------------------------------
       .              /// let expected = mat![[4.0, 5.0, 6.0], [1.0, 2.0, 3.0]];
       .              /// assert_eq!(expected.as_ref(), reversed_rows);
       .              /// ```
       .              #[inline(always)]
       .              #[must_use]
       .              pub fn reverse_rows(self) -> Self {
       .                  let nrows = self.nrows();
       .                  let ncols = self.ncols();
  -3,280 (-0.0%)          let row_stride = -self.row_stride();
       .                  let col_stride = self.col_stride();
       .          
       0                  let ptr = self.ptr_at(if nrows == 0 { 0 } else { nrows - 1 }, 0);
       .                  unsafe { Self::from_raw_parts(ptr, nrows, ncols, row_stride, col_stride) }
       .              }
       .          
       .              /// Returns a view over the `self`, with the columns in reversed order.
       .              ///
       .              /// # Example
       .              /// ```
       .              /// use faer_core::mat;
-- line 4461 ----------------------------------------
-- line 4468 ----------------------------------------
       .              /// assert_eq!(expected.as_ref(), reversed_cols);
       .              /// ```
       .              #[inline(always)]
       .              #[must_use]
       .              pub fn reverse_cols(self) -> Self {
       .                  let nrows = self.nrows();
       .                  let ncols = self.ncols();
       .                  let row_stride = self.row_stride();
  -1,640 (-0.0%)          let col_stride = -self.col_stride();
   1,640  (0.0%)          let ptr = self.ptr_at(0, if ncols == 0 { 0 } else { ncols - 1 });
       .                  unsafe { Self::from_raw_parts(ptr, nrows, ncols, row_stride, col_stride) }
       .              }
       .          
       .              /// Returns a view over the `self`, with the rows and the columns in reversed order.
       .              ///
       .              /// # Example
       .              /// ```
       .              /// use faer_core::mat;
-- line 4485 ----------------------------------------
-- line 4491 ----------------------------------------
       .              /// let expected = mat![[6.0, 5.0, 4.0], [3.0, 2.0, 1.0]];
       .              /// assert_eq!(expected.as_ref(), reversed);
       .              /// ```
       .              #[inline(always)]
       .              #[must_use]
       .              pub fn reverse_rows_and_cols(self) -> Self {
       .                  let nrows = self.nrows();
       .                  let ncols = self.ncols();
       0                  let row_stride = -self.row_stride();
       .                  let col_stride = -self.col_stride();
       .          
       .                  let ptr = self.ptr_at(
       0                      if nrows == 0 { 0 } else { nrows - 1 },
       .                      if ncols == 0 { 0 } else { ncols - 1 },
       .                  );
       .                  unsafe { Self::from_raw_parts(ptr, nrows, ncols, row_stride, col_stride) }
       .              }
       .          
       .              /// Returns a view over the submatrix starting at indices `(row_start, col_start)`, and with
       .              /// dimensions `(nrows, ncols)`.
       .              ///
-- line 4511 ----------------------------------------
-- line 4533 ----------------------------------------
       .              /// let expected = mat![[7.0, 11.0], [8.0, 12.0f64]];
       .              /// assert_eq!(expected.as_ref(), submatrix);
       .              /// ```
       .              #[track_caller]
       .              #[inline(always)]
       .              pub fn submatrix(self, row_start: usize, col_start: usize, nrows: usize, ncols: usize) -> Self {
       .                  assert!(row_start <= self.nrows());
       .                  assert!(col_start <= self.ncols());
  71,114  (0.1%)          assert!(nrows <= self.nrows() - row_start);
  -3,280 (-0.0%)          assert!(ncols <= self.ncols() - col_start);
       .                  let row_stride = self.row_stride();
       .                  let col_stride = self.col_stride();
       .                  unsafe {
       .                      Self::from_raw_parts(
       .                          self.ptr_at(row_start, col_start),
       .                          nrows,
       .                          ncols,
       .                          row_stride,
-- line 4550 ----------------------------------------
-- line 4662 ----------------------------------------
       .                  let size = self.nrows().min(self.ncols());
       .                  let row_stride = self.row_stride();
       .                  let col_stride = self.col_stride();
       .                  unsafe { Self::from_raw_parts(self.as_ptr(), size, 1, row_stride + col_stride, 0) }
       .              }
       .          
       .              /// Returns an owning [`Mat`] of the data.
       .              #[inline]
       0              pub fn to_owned(&self) -> Mat<E::Canonical>
       .              where
       .                  E: Conjugate,
       .              {
       .                  let mut mat = Mat::new();
       .                  mat.resize_with(self.nrows(), self.ncols(), |row, col| unsafe {
       .                      self.read_unchecked(row, col).canonicalize()
       .                  });
       0                  mat
       0              }
       .          
       .              /// Returns `true` if any of the elements is NaN, otherwise returns `false`.
       .              #[inline]
       .              pub fn has_nan(&self) -> bool
       .              where
       .                  E: ComplexField,
       .              {
       .                  let mut found_nan = false;
-- line 4687 ----------------------------------------
-- line 4708 ----------------------------------------
       .              #[inline]
       .              pub fn cwise(self) -> Zip<(Self,)> {
       .                  Zip { tuple: (self,) }
       .              }
       .          
       .              /// Returns a view over the matrix.
       .              #[inline]
       .              pub fn as_ref(&self) -> MatRef<'_, E> {
      -1 (-0.0%)          *self
       .              }
       .          
       .              #[doc(hidden)]
       .              #[inline(always)]
       .              pub unsafe fn const_cast(self) -> MatMut<'a, E> {
       0                  MatMut {
       .                      inner: self.inner,
       .                      __marker: PhantomData,
       .                  }
       .              }
       .          }
       .          
       .          impl<E: SimpleEntity> core::ops::Index<(usize, usize)> for MatRef<'_, E> {
       .              type Output = E;
-- line 4730 ----------------------------------------
-- line 4896 ----------------------------------------
       .              #[track_caller]
       .              pub unsafe fn from_raw_parts(
       .                  ptr: E::Group<*mut E::Unit>,
       .                  nrows: usize,
       .                  ncols: usize,
       .                  row_stride: isize,
       .                  col_stride: isize,
       .              ) -> Self {
       7  (0.0%)          Self {
       .                      inner: MatImpl {
       .                          ptr: E::into_copy(ptr),
       .                          nrows,
       .                          ncols,
       .                          row_stride,
       .                          col_stride,
       .                      },
       .                      __marker: PhantomData,
-- line 4912 ----------------------------------------
-- line 4917 ----------------------------------------
       .              #[inline(always)]
       .              pub fn as_ptr(self) -> E::Group<*mut E::Unit> {
       .                  E::from_copy(self.inner.ptr)
       .              }
       .          
       .              /// Returns the number of rows of the matrix.
       .              #[inline(always)]
       .              pub fn nrows(&self) -> usize {
       0                  self.inner.nrows
       .              }
       .          
       .              /// Returns the number of columns of the matrix.
       .              #[inline(always)]
       .              pub fn ncols(&self) -> usize {
       0                  self.inner.ncols
       .              }
       .          
       .              /// Returns the row stride of the matrix, specified in number of elements, not in bytes.
       .              #[inline(always)]
       .              pub fn row_stride(&self) -> isize {
       0                  self.inner.row_stride
       .              }
       .          
       .              /// Returns the column stride of the matrix, specified in number of elements, not in bytes.
       .              #[inline(always)]
       .              pub fn col_stride(&self) -> isize {
       .                  self.inner.col_stride
       .              }
       .          
       .              /// Returns raw pointers to the element at the given indices.
       .              #[inline(always)]
       .              pub fn ptr_at(self, row: usize, col: usize) -> E::Group<*mut E::Unit> {
       .                  let row_stride = self.inner.row_stride;
       .                  let col_stride = self.inner.col_stride;
       .                  E::map(self.as_ptr(), |ptr| {
       .                      ptr.wrapping_offset(row as isize * row_stride)
       0                          .wrapping_offset(col as isize * col_stride)
       .                  })
       .              }
       .          
       .              /// Returns raw pointers to the element at the given indices, assuming the provided indices
       .              /// are within the matrix dimensions.
       .              ///
       .              /// # Safety
       .              /// The behavior is undefined if any of the following conditions are violated:
-- line 4961 ----------------------------------------
-- line 4982 ----------------------------------------
       .              /// * bottom right.
       .              ///
       .              /// # Panics
       .              /// The function panics if any of the following conditions are violated:
       .              /// * `row <= self.nrows()`.
       .              /// * `col <= self.ncols()`.
       .              #[inline(always)]
       .              #[track_caller]
       0              pub fn split_at(self, row: usize, col: usize) -> [Self; 4] {
       .                  let [top_left, top_right, bot_left, bot_right] = self.into_const().split_at(row, col);
       .                  unsafe {
       .                      [
       .                          top_left.const_cast(),
       .                          top_right.const_cast(),
       .                          bot_left.const_cast(),
       .                          bot_right.const_cast(),
       .                      ]
-- line 4998 ----------------------------------------
-- line 5099 ----------------------------------------
       .              /// The behavior is undefined if any of the following conditions are violated:
       .              /// * `row < self.nrows()`.
       .              /// * `col < self.ncols()`.
       .              #[inline(always)]
       .              #[track_caller]
       .              pub unsafe fn write_unchecked(&mut self, row: usize, col: usize, value: E) {
       .                  let units = value.into_units();
       .                  let zipped = E::zip(units, self.rb_mut().ptr_inbounds_at(row, col));
  73,254  (0.1%)          E::map(zipped, |(unit, ptr)| *ptr = unit);
       .              }
       .          
       .              /// Writes the value to the element at the given indices, with bound checks.
       .              ///
       .              /// # Panics
       .              /// The function panics if any of the following conditions are violated:
       .              /// * `row < self.nrows()`.
       .              /// * `col < self.ncols()`.
-- line 5115 ----------------------------------------
-- line 5165 ----------------------------------------
       .              /// let transpose = view.transpose();
       .              ///
       .              /// let mut expected = mat![[1.0, 4.0], [2.0, 5.0], [3.0, 6.0]];
       .              /// assert_eq!(expected.as_mut(), transpose);
       .              /// ```
       .              #[inline(always)]
       .              #[must_use]
       .              pub fn transpose(self) -> Self {
       0                  Self {
       .                      inner: MatImpl {
       .                          ptr: self.inner.ptr,
       .                          nrows: self.inner.ncols,
       .                          ncols: self.inner.nrows,
       .                          row_stride: self.inner.col_stride,
       .                          col_stride: self.inner.row_stride,
       .                      },
       .                      __marker: PhantomData,
-- line 5181 ----------------------------------------
-- line 5539 ----------------------------------------
       .                      }
       .                  } else {
       .                      let cap = row_capacity
       .                          .checked_mul(col_capacity)
       .                          .unwrap_or_else(capacity_overflow);
       .                      let cap_bytes = cap
       .                          .checked_mul(core::mem::size_of::<T>())
       .                          .unwrap_or_else(capacity_overflow);
       0                      if cap_bytes > isize::MAX as usize {
       .                          capacity_overflow::<()>();
       .                      }
       .          
       .                      use alloc::alloc::{alloc, handle_alloc_error, Layout};
       .          
       .                      let layout = Layout::from_size_align(cap_bytes, align_for::<T>())
       .                          .ok()
       .                          .unwrap_or_else(capacity_overflow);
       .          
     -12 (-0.0%)              let ptr = if layout.size() == 0 {
       .                          dangling
       .                      } else {
       .                          // SAFETY: we checked that layout has non zero size
       .                          let ptr = unsafe { alloc(layout) } as *mut T;
       0                          if ptr.is_null() {
       .                              handle_alloc_error(layout)
       .                          } else {
       .                              // SAFETY: we checked that the pointer is not null
       .                              unsafe { NonNull::<T>::new_unchecked(ptr) }
       .                          }
       .                      };
       .          
       .                      Self {
-- line 5570 ----------------------------------------
-- line 5578 ----------------------------------------
       .          
       .          impl<T: 'static> Drop for RawMatUnit<T> {
       .              fn drop(&mut self) {
       .                  use alloc::alloc::{dealloc, Layout};
       .                  // this cannot overflow because we already allocated this much memory
       .                  // self.row_capacity.wrapping_mul(self.col_capacity) may overflow if T is a zst
       .                  // but that's fine since we immediately multiply it by 0.
       .                  let alloc_size =
       1  (0.0%)              self.row_capacity.wrapping_mul(self.col_capacity) * core::mem::size_of::<T>();
       5  (0.0%)          if alloc_size != 0 {
       .                      // SAFETY: pointer was allocated with alloc::alloc::alloc
       .                      unsafe {
       .                          dealloc(
       .                              self.ptr.as_ptr() as *mut u8,
       .                              Layout::from_size_align_unchecked(alloc_size, align_for::<T>()),
       .                          );
       .                      }
       .                  }
-- line 5595 ----------------------------------------
-- line 5649 ----------------------------------------
       .                      col_capacity,
       .                  }
       .              }
       .          }
       .          
       .          impl<E: Entity> Drop for RawMat<E> {
       .              fn drop(&mut self) {
       .                  // implicitly dropped
       1  (0.0%)          let _ = E::map(E::from_copy(self.ptr), |ptr| RawMatUnit {
       .                      ptr,
      -2 (-0.0%)              row_capacity: self.row_capacity,
       .                      col_capacity: self.col_capacity,
       .                  });
       .              }
       .          }
       .          
       .          struct BlockGuard<E: Entity> {
       .              ptr: E::GroupCopy<*mut E::Unit>,
       .              nrows: usize,
-- line 5667 ----------------------------------------
-- line 5749 ----------------------------------------
       .                          E::from_units(E::deref(this.get_unchecked(i, j)))
       .                      })
       .                  }
       .              }
       .          }
       .          
       .          impl<T> MatUnit<T> {
       .              #[cold]
       0              fn do_reserve_exact(&mut self, mut new_row_capacity: usize, mut new_col_capacity: usize) {
       0                  new_row_capacity = self.raw.row_capacity.max(new_row_capacity);
       0                  new_col_capacity = self.raw.col_capacity.max(new_col_capacity);
       .          
       0                  let new_ptr = if self.raw.row_capacity == new_row_capacity
       .                      && self.raw.row_capacity != 0
       .                      && self.raw.col_capacity != 0
       .                  {
       .                      // case 1:
       .                      // we have enough row capacity, and we've already allocated memory.
       .                      // use realloc to get extra column memory
       .          
       .                      use alloc::alloc::{handle_alloc_error, realloc, Layout};
-- line 5769 ----------------------------------------
-- line 5812 ----------------------------------------
       .                      // use alloc and move stuff manually.
       .          
       .                      // allocate new memory region
       .                      let new_ptr = {
       .                          let m = ManuallyDrop::new(RawMatUnit::<T>::new(new_row_capacity, new_col_capacity));
       .                          m.ptr.as_ptr()
       .                      };
       .          
       0                      let old_ptr = self.raw.ptr.as_ptr();
       .          
       .                      // copy each column to new matrix
       0                      for j in 0..self.ncols {
       .                          // SAFETY:
       .                          // * pointer offsets can't overflow since they're within an already allocated
       .                          // memory region less than isize::MAX bytes in size.
       .                          // * new and old allocation can't overlap, so copy_nonoverlapping is fine here.
       .                          unsafe {
       .                              let old_ptr = old_ptr.add(j * self.raw.row_capacity);
       .                              let new_ptr = new_ptr.add(j * new_row_capacity);
       .                              core::ptr::copy_nonoverlapping(old_ptr, new_ptr, self.nrows);
-- line 5831 ----------------------------------------
-- line 5838 ----------------------------------------
       .                          // pointer.
       .                          ptr: unsafe { NonNull::new_unchecked(old_ptr) },
       .                          row_capacity: self.raw.row_capacity,
       .                          col_capacity: self.raw.col_capacity,
       .                      };
       .          
       .                      new_ptr
       .                  };
       0                  self.raw.row_capacity = new_row_capacity;
       0                  self.raw.col_capacity = new_col_capacity;
       0                  self.raw.ptr = unsafe { NonNull::<T>::new_unchecked(new_ptr) };
       0              }
       .          }
       .          
       .          impl<T> Drop for MatUnit<T> {
       .              fn drop(&mut self) {
       .                  let mut ptr = self.raw.ptr.as_ptr();
       .                  let nrows = self.nrows;
       .                  let ncols = self.ncols;
       .                  let cs = self.raw.row_capacity;
-- line 5857 ----------------------------------------
-- line 5871 ----------------------------------------
       .              fn default() -> Self {
       .                  Self::new()
       .              }
       .          }
       .          
       .          impl<E: Entity> Mat<E> {
       .              #[inline]
       .              pub fn new() -> Self {
       3  (0.0%)          Self {
       .                      raw: RawMat::<E> {
       .                          ptr: E::map_copy(E::UNIT, |()| NonNull::<E::Unit>::dangling()),
       .                          row_capacity: 0,
       .                          col_capacity: 0,
       .                      },
       .                      nrows: 0,
       .                      ncols: 0,
       .                  }
-- line 5887 ----------------------------------------
-- line 5902 ----------------------------------------
       .                  }
       .              }
       .          
       .              /// Returns a new matrix with dimensions `(nrows, ncols)`, filled with the provided function.
       .              ///
       .              /// # Panics
       .              /// The function panics if the total capacity in bytes exceeds `isize::MAX`.
       .              #[inline]
       0              pub fn from_fn(nrows: usize, ncols: usize, f: impl FnMut(usize, usize) -> E) -> Self {
       .                  let mut this = Self::new();
       .                  this.resize_with(nrows, ncols, f);
     -20 (-0.0%)          this
       0              }
       .          
       .              /// Returns a new matrix with dimensions `(nrows, ncols)`, filled with zeros.
       .              ///
       .              /// # Panics
       .              /// The function panics if the total capacity in bytes exceeds `isize::MAX`.
       .              #[inline]
       .              pub fn zeros(nrows: usize, ncols: usize) -> Self
       .              where
       .                  E: ComplexField,
       .              {
      -4 (-0.0%)          Self::from_fn(nrows, ncols, |_, _| E::zero())
       .              }
       .          
       .              /// Returns a new matrix with dimensions `(nrows, ncols)`, filled with zeros, except the main
       .              /// diagonal which is filled with ones.
       .              ///
       .              /// # Panics
       .              /// The function panics if the total capacity in bytes exceeds `isize::MAX`.
       .              #[inline]
-- line 5933 ----------------------------------------
-- line 5952 ----------------------------------------
       .              pub unsafe fn set_dims(&mut self, nrows: usize, ncols: usize) {
       .                  self.nrows = nrows;
       .                  self.ncols = ncols;
       .              }
       .          
       .              /// Returns a pointer to the data of the matrix.
       .              #[inline]
       .              pub fn as_ptr(&self) -> E::Group<*const E::Unit> {
     -11 (-0.0%)          E::map(E::from_copy(self.raw.ptr), |ptr| {
       .                      ptr.as_ptr() as *const E::Unit
       .                  })
       .              }
       .          
       .              /// Returns a mutable pointer to the data of the matrix.
       .              #[inline]
       .              pub fn as_mut_ptr(&mut self) -> E::Group<*mut E::Unit> {
      12  (0.0%)          E::map(E::from_copy(self.raw.ptr), |ptr| ptr.as_ptr())
       .              }
       .          
       .              /// Returns the number of rows of the matrix.
       .              #[inline]
       .              pub fn nrows(&self) -> usize {
      -9 (-0.0%)          self.nrows
       .              }
       .          
       .              /// Returns the number of columns of the matrix.
       .              #[inline]
       .              pub fn ncols(&self) -> usize {
      -4 (-0.0%)          self.ncols
       .              }
       .          
       .              /// Returns the row capacity, that is, the number of rows that the matrix is able to hold
       .              /// without needing to reallocate, excluding column insertions.
       .              #[inline]
       .              pub fn row_capacity(&self) -> usize {
       1  (0.0%)          self.raw.row_capacity
       .              }
       .          
       .              /// Returns the column capacity, that is, the number of columns that the matrix is able to hold
       .              /// without needing to reallocate, excluding row insertions.
       .              #[inline]
       .              pub fn col_capacity(&self) -> usize {
       .                  self.raw.col_capacity
       .              }
-- line 5995 ----------------------------------------
-- line 6003 ----------------------------------------
       .          
       .              /// Returns the offset between the first elements of two successive columns in the matrix.
       .              #[inline]
       .              pub fn col_stride(&self) -> isize {
       .                  self.row_capacity() as isize
       .              }
       .          
       .              #[cold]
      12  (0.0%)      fn do_reserve_exact(&mut self, mut new_row_capacity: usize, new_col_capacity: usize) {
       .                  if is_vectorizable::<E::Unit>() {
       .                      let align_factor = align_for::<E::Unit>() / core::mem::size_of::<E::Unit>();
       0                      new_row_capacity =
       0                          (new_row_capacity + (align_factor - 1)) / align_factor * align_factor;
       .                  }
       .          
       .                  use core::mem::swap;
       0                  let nrows = self.nrows;
       0                  let ncols = self.ncols;
       0                  let old_row_capacity = self.raw.row_capacity;
       0                  let old_col_capacity = self.raw.col_capacity;
       .          
       .                  let mut this = Self::new();
       .                  swap(self, &mut this);
       .          
      12  (0.0%)          let mut this_group = E::map(E::from_copy(this.raw.ptr), |ptr| MatUnit {
       .                      raw: RawMatUnit {
       .                          ptr,
       .                          row_capacity: old_row_capacity,
       .                          col_capacity: old_col_capacity,
       .                      },
       .                      nrows,
       .                      ncols,
       .                  });
       .          
       .                  E::map(E::as_mut(&mut this_group), |mat_unit| {
     -12 (-0.0%)              mat_unit.do_reserve_exact(new_row_capacity, new_col_capacity);
       .                  });
       .          
       0                  let this_group = E::map(this_group, ManuallyDrop::new);
       .                  this.raw.ptr = E::into_copy(E::map(this_group, |mat_unit| mat_unit.raw.ptr));
       .                  this.raw.row_capacity = new_row_capacity;
       .                  this.raw.col_capacity = new_col_capacity;
       .                  swap(self, &mut this);
      12  (0.0%)      }
       .          
       .              /// Reserves the minimum capacity for `row_capacity` rows and `col_capacity`
       .              /// columns without reallocating. Does nothing if the capacity is already sufficient.
       .              ///
       .              /// # Panics
       .              /// The function panics if the new total capacity in bytes exceeds `isize::MAX`.
       .              #[inline]
       .              pub fn reserve_exact(&mut self, row_capacity: usize, col_capacity: usize) {
       0                  if self.row_capacity() >= row_capacity && self.col_capacity() >= col_capacity {
       .                      // do nothing
       .                  } else if core::mem::size_of::<E::Unit>() == 0 {
       .                      self.raw.row_capacity = self.row_capacity().max(row_capacity);
       .                      self.raw.col_capacity = self.col_capacity().max(col_capacity);
       .                  } else {
      -1 (-0.0%)              self.do_reserve_exact(row_capacity, col_capacity);
       .                  }
       .              }
       .          
       .              unsafe fn erase_block(
       .                  &mut self,
       .                  row_start: usize,
       .                  row_end: usize,
       .                  col_start: usize,
-- line 6069 ----------------------------------------
-- line 6106 ----------------------------------------
       .                      ptr: E::map_copy(ptr, |ptr| ptr.wrapping_add(row_start)),
       .                      nrows: row_end - row_start,
       .                      ncols: 0,
       .                      cs: self.col_stride(),
       .                  };
       .          
       .                  for j in col_start..col_end {
       .                      let ptr_j = E::map_copy(ptr, |ptr| {
      -5 (-0.0%)                  ptr.wrapping_offset(j as isize * self.col_stride())
       .                      });
       .          
       .                      // create a guard for the same purpose as the previous one
       .                      let mut col_guard = ColGuard::<E> {
       .                          // SAFETY: same as above
       .                          ptr: E::map_copy(ptr_j, |ptr_j| ptr_j.wrapping_add(row_start)),
       .                          nrows: 0,
       .                      };
-- line 6122 ----------------------------------------
-- line 6171 ----------------------------------------
       .                  &mut self,
       .                  f: &mut F,
       .                  new_ncols: usize,
       .              ) {
       .                  let old_ncols = self.ncols();
       .          
       .                  debug_assert!(new_ncols > old_ncols);
       .          
      -3 (-0.0%)          self.insert_block_with(f, 0, self.nrows(), old_ncols, new_ncols);
      -2 (-0.0%)          self.ncols = new_ncols;
       .              }
       .          
       .              unsafe fn insert_last_rows_with<F: FnMut(usize, usize) -> E>(
       .                  &mut self,
       .                  f: &mut F,
       .                  new_nrows: usize,
       .              ) {
       .                  let old_nrows = self.nrows();
       .          
       .                  debug_assert!(new_nrows > old_nrows);
       .          
     -22 (-0.0%)          self.insert_block_with(f, old_nrows, new_nrows, 0, self.ncols());
       .                  self.nrows = new_nrows;
       .              }
       .          
       .              /// Resizes the matrix in-place so that the new dimensions are `(new_nrows, new_ncols)`.
       .              /// Elements that are now out of bounds are dropped, while new elements are created with the
       .              /// given function `f`, so that elements at indices `(i, j)` are created by calling `f(i, j)`.
       .              pub fn resize_with(
       .                  &mut self,
-- line 6200 ----------------------------------------
-- line 6201 ----------------------------------------
       .                  new_nrows: usize,
       .                  new_ncols: usize,
       .                  f: impl FnMut(usize, usize) -> E,
       .              ) {
       .                  let mut f = f;
       .                  let old_nrows = self.nrows();
       .                  let old_ncols = self.ncols();
       .          
      -6 (-0.0%)          if new_ncols <= old_ncols {
       .                      self.erase_last_cols(new_ncols);
       .                      if new_nrows <= old_nrows {
       .                          self.erase_last_rows(new_nrows);
       .                      } else {
       .                          self.reserve_exact(new_nrows, new_ncols);
       .                          unsafe {
       .                              self.insert_last_rows_with(&mut f, new_nrows);
       .                          }
       .                      }
       .                  } else {
       0                      if new_nrows <= old_nrows {
       .                          self.erase_last_rows(new_nrows);
       .                      } else {
       .                          self.reserve_exact(new_nrows, new_ncols);
       .                          unsafe {
       .                              self.insert_last_rows_with(&mut f, new_nrows);
       .                          }
       .                      }
       .                      self.reserve_exact(new_nrows, new_ncols);
-- line 6228 ----------------------------------------
-- line 6636 ----------------------------------------
       .          
       .          #[inline]
       .          #[doc(hidden)]
       .          pub fn join_raw(
       .              op_a: impl Send + FnOnce(Parallelism),
       .              op_b: impl Send + FnOnce(Parallelism),
       .              parallelism: Parallelism,
       .          ) {
       0              fn implementation(
       .                  op_a: &mut (dyn Send + FnMut(Parallelism)),
       .                  op_b: &mut (dyn Send + FnMut(Parallelism)),
       .                  parallelism: Parallelism,
       .              ) {
       0                  match parallelism {
       0                      Parallelism::None => (op_a(parallelism), op_b(parallelism)),
       .                      Parallelism::Rayon(n_threads) => {
       0                          if n_threads == 1 {
       .                              (op_a(Parallelism::None), op_b(Parallelism::None))
       .                          } else {
       .                              let n_threads = if n_threads > 0 {
       .                                  n_threads
       .                              } else {
       .                                  rayon::current_num_threads()
       .                              };
       0                              let parallelism = Parallelism::Rayon(n_threads - n_threads / 2);
       0                              rayon::join(|| op_a(parallelism), || op_b(parallelism))
       .                          }
       .                      }
       .                  };
       0              }
       0              let mut op_a = Some(op_a);
       0              let mut op_b = Some(op_b);
       0              implementation(
  -3,586 (-0.0%)          &mut |parallelism| (op_a.take().unwrap())(parallelism),
  -3,586 (-0.0%)          &mut |parallelism| (op_b.take().unwrap())(parallelism),
       .                  parallelism,
       .              )
       .          }
       .          
       .          #[inline]
       .          #[doc(hidden)]
       .          pub fn for_each_raw(n_tasks: usize, op: impl Send + Sync + Fn(usize), parallelism: Parallelism) {
       .              fn implementation(
-- line 6678 ----------------------------------------
-- line 6984 ----------------------------------------
       .              fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
       .                  struct DebugRow<'a, T: Entity>(MatRef<'a, T>);
       .          
       .                  impl<'a, T: Entity> Debug for DebugRow<'a, T> {
       .                      fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
       .                          let mut j = 0;
       .                          f.debug_list()
       .                              .entries(core::iter::from_fn(|| {
      -2 (-0.0%)                          let ret = if j < self.0.ncols() {
       .                                      Some(T::from_units(T::deref(self.0.get(0, j))))
       .                                  } else {
       .                                      None
       .                                  };
       .                                  j += 1;
       .                                  ret
       .                              }))
       .                              .finish()
       .                      }
       .                  }
       .          
       0                  writeln!(f, "[")?;
       .                  for i in 0..self.nrows() {
       .                      let row = self.subrows(i, 1);
       0                      DebugRow(row).fmt(f)?;
       0                      f.write_str(",\n")?;
       .                  }
       .                  write!(f, "]")
       .              }
       .          }
       .          
       .          impl<'a, E: Entity> Debug for MatMut<'a, E> {
       .              fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
       .                  self.rb().fmt(f)
-- line 7016 ----------------------------------------
-- line 7026 ----------------------------------------
       .          impl<LhsE: Conjugate, RhsE: Conjugate<Canonical = LhsE::Canonical>> core::ops::Mul<MatRef<'_, RhsE>>
       .              for MatRef<'_, LhsE>
       .          where
       .              LhsE::Canonical: ComplexField,
       .          {
       .              type Output = Mat<LhsE::Canonical>;
       .          
       .              #[track_caller]
      22  (0.0%)      fn mul(self, rhs: MatRef<'_, RhsE>) -> Self::Output {
       .                  let mut out = Mat::zeros(self.nrows(), rhs.ncols());
       .                  mul::matmul(
       .                      out.as_mut(),
       6  (0.0%)              self,
       4  (0.0%)              rhs,
       .                      None,
       .                      LhsE::Canonical::one(),
       .                      get_global_parallelism(),
       .                  );
       0                  out
      16  (0.0%)      }
       .          }
       .          
       .          #[cfg(test)]
       .          mod tests {
       .              macro_rules! impl_unit_entity {
       .                  ($ty: ty) => {
       .                      unsafe impl Entity for $ty {
       .                          type Unit = Self;
-- line 7053 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/mul.rs
--------------------------------------------------------------------------------
Ir______________ 

 202,975  (0.2%)  <unknown (line 0)>

-- line 192 ----------------------------------------
       .                          a_x_b_accumulate_prologue2::<CONJ_A, E, S>(simd, a_head, b_head)
       .                      } else {
       .                          a_x_b_accumulate_prologue1::<CONJ_A, E, S>(simd, a_head, b_head)
       .                      };
       .          
       .                      let mut rem = 0;
       .                      E::map(E::as_ref(&a_tail), |slice| rem = slice.len());
       .          
       0                      let mut acc = if len > rem {
       .                          E::simd_reduce_add(simd, prologue)
       .                      } else {
       .                          E::zero()
       .                      };
       .          
       .                      let a = {
       .                          #[inline(always)]
       .                          |i: usize| unsafe {
       0                              let a = E::from_units(E::deref(E::map(E::copy(&a_tail), |slice| {
       .                                  slice.get_unchecked(i)
       .                              })));
       .          
       .                              if CONJ_A {
       .                                  a.conj()
       .                              } else {
       .                                  a
       .                              }
-- line 217 ----------------------------------------
-- line 324 ----------------------------------------
       .              #[inline(always)]
       .              pub fn inner_prod_with_conj_arch<E: ComplexField>(
       .                  arch: pulp::Arch,
       .                  lhs: MatRef<'_, E>,
       .                  conj_lhs: Conj,
       .                  rhs: MatRef<'_, E>,
       .                  conj_rhs: Conj,
       .              ) -> E {
      -2 (-0.0%)          assert!(lhs.nrows() == rhs.nrows());
 -36,628 (-0.0%)          assert!(lhs.ncols() == 1);
 -36,628 (-0.0%)          assert!(rhs.ncols() == 1);
       .                  let nrows = lhs.nrows();
       .                  let mut a = lhs;
       .                  let mut b = rhs;
 -73,252 (-0.1%)          if a.row_stride() < 0 {
       .                      a = a.reverse_rows();
       .                      b = b.reverse_rows();
       .                  }
       .          
-146,500 (-0.1%)          let res = if E::HAS_SIMD && a.row_stride() == 1 && b.row_stride() == 1 {
       .                      let a = E::map(a.as_ptr(), |ptr| unsafe {
       .                          core::slice::from_raw_parts(ptr, nrows)
       .                      });
       .                      let b = E::map(b.as_ptr(), |ptr| unsafe {
       .                          core::slice::from_raw_parts(ptr, nrows)
       .                      });
       .          
       2  (0.0%)              if conj_lhs == conj_rhs {
       8  (0.0%)                  arch.dispatch(AccNoConjAxB::<E> { a, b })
       .                      } else {
 146,504  (0.1%)                  arch.dispatch(AccConjAxB::<E> { a, b })
       .                      }
       .                  } else {
       .                      unsafe {
       .                          let mut acc = E::zero();
       .                          if conj_lhs == conj_rhs {
       .                              for i in 0..nrows {
       .                                  acc = acc.add(&E::mul(&a.read_unchecked(i, 0), &b.read_unchecked(i, 0)));
       .                              }
-- line 362 ----------------------------------------
-- line 374 ----------------------------------------
       .          
       .                  match conj_rhs {
       .                      Conj::Yes => res.conj(),
       .                      Conj::No => res,
       .                  }
       .              }
       .          
       .              #[inline]
-329,652 (-0.3%)      pub fn inner_prod_with_conj<E: ComplexField>(
       .                  lhs: MatRef<'_, E>,
       .                  conj_lhs: Conj,
       .                  rhs: MatRef<'_, E>,
       .                  conj_rhs: Conj,
       .              ) -> E {
-293,024 (-0.3%)          inner_prod_with_conj_arch(pulp::Arch::new(), lhs, conj_lhs, rhs, conj_rhs)
-219,768 (-0.2%)      }
       .          }
       .          
       .          mod matvec_rowmajor {
       .              use super::*;
       .              use assert2::assert;
       .          
   3,280  (0.0%)      fn matvec_with_conj_impl<E: ComplexField>(
       .                  acc: MatMut<'_, E>,
       .                  a: MatRef<'_, E>,
       .                  conj_a: Conj,
       .                  b: MatRef<'_, E>,
       .                  conj_b: Conj,
       .                  alpha: Option<E>,
       .                  beta: E,
       .              ) {
       .                  let m = a.nrows();
       .                  let n = a.ncols();
       .          
       0                  assert!(b.nrows() == n);
       0                  assert!(b.ncols() == 1);
       0                  assert!(acc.nrows() == m);
       0                  assert!(acc.ncols() == 1);
       .          
       0                  assert!(a.col_stride() == 1);
       0                  assert!(b.row_stride() == 1);
       .          
       .                  let mut acc = acc;
       .          
       .                  for i in 0..m {
   3,280  (0.0%)              let a = a.submatrix(i, 0, 1, n);
-402,886 (-0.4%)              let res = inner_prod::inner_prod_with_conj(a.transpose(), conj_a, b, conj_b);
  34,986  (0.0%)              match &alpha {
       .                          Some(alpha) => {
       .                              acc.write(i, 0, E::add(&alpha.mul(&acc.read(i, 0)), &beta.mul(&res)))
       .                          }
       .                          None => acc.write(i, 0, beta.mul(&res)),
       .                      }
       .                  }
       0              }
       .          
       .              pub fn matvec_with_conj<E: ComplexField>(
       .                  acc: MatMut<'_, E>,
       .                  lhs: MatRef<'_, E>,
       .                  conj_lhs: Conj,
       .                  rhs: MatRef<'_, E>,
       .                  conj_rhs: Conj,
       .                  alpha: Option<E>,
       .                  beta: E,
       .              ) {
       0                  if rhs.row_stride() == 1 {
 -26,240 (-0.0%)              matvec_with_conj_impl(acc, lhs, conj_lhs, rhs, conj_rhs, alpha, beta);
       .                  } else {
       .                      matvec_with_conj_impl(
       .                          acc,
       .                          lhs,
       .                          conj_lhs,
       .                          rhs.to_owned().as_ref(),
       .                          conj_rhs,
       .                          alpha,
-- line 448 ----------------------------------------
-- line 476 ----------------------------------------
       .                      let (acc_head, acc_tail) = slice_as_mut_simd::<E, S>(self.acc);
       .                      {
       .                          let b = E::simd_splat(simd, self.b.clone());
       .          
       .                          for (acc_, a) in zip(E::into_iter(acc_head), E::into_iter(a_head)) {
       .                              let mut acc = E::deref(E::rb(E::as_ref(&acc_)));
       .                              let a = E::deref(a);
       .                              acc = E::simd_mul_adde(simd, E::copy(&b), a, acc);
       0                              E::map(E::zip(acc_, acc), |(acc_, acc)| *acc_ = acc);
       .                          }
       .                      }
       .          
       .                      let b = self.b;
       .                      for (acc_, a) in zip(E::into_iter(acc_tail), E::into_iter(a_tail)) {
       .                          let mut acc = E::from_units(E::deref(E::rb(E::as_ref(&acc_))));
       .                          let a = E::from_units(E::deref(a));
       .                          acc = E::mul_adde(&b, &a, &acc);
       .                          let acc = E::into_units(acc);
       0                          E::map(E::zip(acc_, acc), |(acc_, acc)| *acc_ = acc);
       .                      }
       .                  }
       .              }
       .          
       .              impl<E: ComplexField> pulp::WithSimd for ConjImpl<'_, E> {
       .                  type Output = ();
       .          
       .                  #[inline(always)]
-- line 502 ----------------------------------------
-- line 520 ----------------------------------------
       .                          let a = E::from_units(E::deref(a));
       .                          acc = E::conj_mul_adde(&a, &b, &acc);
       .                          let acc = E::into_units(acc);
       .                          E::map(E::zip(acc_, acc), |(acc_, acc)| *acc_ = acc);
       .                      }
       .                  }
       .              }
       .          
   1,640  (0.0%)      fn matvec_with_conj_impl<E: ComplexField>(
       .                  acc: MatMut<'_, E>,
       .                  a: MatRef<'_, E>,
       .                  conj_a: Conj,
       .                  b: MatRef<'_, E>,
       .                  conj_b: Conj,
       .                  beta: E,
       .              ) {
       .                  let m = a.nrows();
       .                  let n = a.ncols();
       .          
       0                  assert!(b.nrows() == n);
       0                  assert!(b.ncols() == 1);
       0                  assert!(acc.nrows() == m);
       0                  assert!(acc.ncols() == 1);
       .          
       0                  assert!(a.row_stride() == 1);
       0                  assert!(acc.row_stride() == 1);
       .          
       .                  let mut acc = E::map(
       0                      acc.as_ptr(),
       .                      #[inline(always)]
       .                      |ptr| unsafe { core::slice::from_raw_parts_mut(ptr, m) },
       .                  );
       .          
       .                  let arch = pulp::Arch::new();
       .                  for j in 0..n {
  38,837  (0.0%)              let a = a.submatrix(0, j, m, 1);
       .                      let acc = E::rb_mut(E::as_mut(&mut acc));
       .          
       .                      let a = E::map(
       .                          a.as_ptr(),
       .                          #[inline(always)]
       .                          |ptr| unsafe { core::slice::from_raw_parts(ptr, m) },
       .                      );
       .                      let b = b.read(j, 0);
       .                      let b = match conj_b {
       .                          Conj::Yes => b.conj(),
       .                          Conj::No => b,
       .                      };
       .                      let b = b.mul(&beta);
       .          
   1,640  (0.0%)              match conj_a {
       .                          Conj::Yes => arch.dispatch(ConjImpl { acc, a, b }),
 169,585  (0.2%)                  Conj::No => arch.dispatch(NoConjImpl { acc, a, b }),
       .                      }
       .                  }
       0              }
       .          
       .              pub fn matvec_with_conj<E: ComplexField>(
       .                  acc: MatMut<'_, E>,
       .                  lhs: MatRef<'_, E>,
       .                  conj_lhs: Conj,
       .                  rhs: MatRef<'_, E>,
       .                  conj_rhs: Conj,
       .                  alpha: Option<E>,
       .                  beta: E,
       .              ) {
       .                  let m = acc.nrows();
       .                  let mut acc = acc;
       0                  if acc.row_stride() == 1 {
       0                      match alpha {
       0                          Some(alpha) if alpha == E::one() => {}
       .                          Some(alpha) => {
       .                              for i in 0..m {
       .                                  acc.write(i, 0, acc.read(i, 0).mul(&alpha));
       .                              }
       .                          }
       .                          None => {
       .                              for i in 0..m {
       .                                  acc.write(i, 0, E::zero());
       .                              }
       .                          }
       .                      }
       .          
 -22,960 (-0.0%)              matvec_with_conj_impl(acc, lhs, conj_lhs, rhs, conj_rhs, beta);
       .                  } else {
       .                      let mut tmp = crate::Mat::<E>::zeros(m, 1);
       .                      matvec_with_conj_impl(tmp.as_mut(), lhs, conj_lhs, rhs, conj_rhs, beta);
       .                      match alpha {
       .                          Some(alpha) => {
       .                              for i in 0..m {
       .                                  acc.write(i, 0, (acc.read(i, 0).mul(&alpha)).add(&tmp.read(i, 0)))
       .                              }
-- line 611 ----------------------------------------
-- line 619 ----------------------------------------
       .                  }
       .              }
       .          }
       .          
       .          #[doc(hidden)]
       .          pub mod matvec {
       .              use super::*;
       .          
   6,560  (0.0%)      pub fn matvec_with_conj<E: ComplexField>(
       .                  acc: MatMut<'_, E>,
       .                  lhs: MatRef<'_, E>,
       .                  conj_lhs: Conj,
       .                  rhs: MatRef<'_, E>,
       .                  conj_rhs: Conj,
       .                  alpha: Option<E>,
       .                  beta: E,
       .              ) {
       0                  let mut acc = acc;
       0                  let mut a = lhs;
       .                  let mut b = rhs;
       .          
       0                  if a.row_stride() < 0 {
       .                      a = a.reverse_rows();
       .                      acc = acc.reverse_rows();
       .                  }
       0                  if a.col_stride() < 0 {
       .                      a = a.reverse_cols();
       .                      b = b.reverse_rows();
       .                  }
       .          
       .                  if E::HAS_SIMD {
       0                      if a.row_stride() == 1 {
       .                          return matvec_colmajor::matvec_with_conj(
  16,400  (0.0%)                      acc, a, conj_lhs, b, conj_rhs, alpha, beta,
       .                          );
       .                      }
       0                      if a.col_stride() == 1 {
       .                          return matvec_rowmajor::matvec_with_conj(
   6,560  (0.0%)                      acc, a, conj_lhs, b, conj_rhs, alpha, beta,
       .                          );
       .                      }
       .                  }
       .          
       .                  let m = a.nrows();
       .                  let n = a.ncols();
       .          
       .                  match alpha {
-- line 665 ----------------------------------------
-- line 682 ----------------------------------------
       .                          Conj::No => b,
       .                      };
       .                      let b = b.mul(&beta);
       .                      for i in 0..m {
       .                          let mul = a.read(i, j).mul(&b);
       .                          acc.write(i, 0, acc.read(i, 0).add(&mul));
       .                      }
       .                  }
       0              }
       .          }
       .          
       .          #[doc(hidden)]
       .          pub mod outer_prod {
       .              use super::*;
       .              use assert2::assert;
       .          
       .              struct NoConjImpl<'a, E: ComplexField> {
-- line 698 ----------------------------------------
-- line 1419 ----------------------------------------
       .              assert!(lhs.ncols() == rhs.nrows());
       .          
       .              let m = acc.nrows();
       .              let n = acc.ncols();
       .              let k = lhs.ncols();
       .          
       .              let mut acc = acc;
       .          
       0              if m == 0 || n == 0 {
       .                  return;
       .              }
       .          
       2  (0.0%)      if m == 1 && n == 1 {
       .                  let mut acc = acc;
     -18 (-0.0%)          let ab = inner_prod::inner_prod_with_conj(lhs.transpose(), conj_lhs, rhs, conj_rhs);
       0                  match alpha {
       .                      Some(alpha) => {
       .                          acc.write(0, 0, E::add(&acc.read(0, 0).mul(&alpha), &ab.mul(&beta)));
       .                      }
       .                      None => {
       .                          acc.write(0, 0, ab.mul(&beta));
       .                      }
       .                  }
       .                  return;
       .              }
       .          
       0              if k == 1 {
       .                  outer_prod::outer_prod_with_conj(
       .                      acc,
       .                      lhs,
       .                      conj_lhs,
       .                      rhs.transpose(),
       .                      conj_rhs,
       .                      alpha,
       .                      beta,
       .                  );
       .                  return;
       .              }
       0              if n == 1 {
   6,560  (0.0%)          matvec::matvec_with_conj(acc, lhs, conj_lhs, rhs, conj_rhs, alpha, beta);
       .                  return;
       .              }
       0              if m == 1 {
       .                  matvec::matvec_with_conj(
       .                      acc.transpose(),
       .                      rhs.transpose(),
       .                      conj_rhs,
       .                      lhs.transpose(),
       .                      conj_lhs,
       .                      alpha,
       .                      beta,
       .                  );
       .                  return;
       .              }
       .          
       .              unsafe {
       0                  if m + n < 32 && k <= 6 {
       .                      macro_rules! small_gemm {
       .                          ($term: expr) => {
       .                              let term = $term;
       .                              match k {
       .                                  0 => match &alpha {
       .                                      Some(alpha) => {
       .                                          for i in 0..m {
       .                                              for j in 0..n {
-- line 1483 ----------------------------------------
-- line 1676 ----------------------------------------
       .                                          }
       .                                      }
       .                                  },
       .                                  _ => unreachable!(),
       .                              }
       .                          };
       .                      }
       .          
    -194 (-0.0%)              match (conj_lhs, conj_rhs) {
       .                          (Conj::Yes, Conj::Yes) => {
       .                              let term = {
       .                                  #[inline(always)]
       .                                  |i, j, depth| {
       .                                      (lhs.read_unchecked(i, depth)
       .                                          .mul(&rhs.read_unchecked(depth, j)))
       .                                      .conj()
       .                                  }
-- line 1692 ----------------------------------------
-- line 1717 ----------------------------------------
       .                          (Conj::No, Conj::No) => {
       .                              let term = {
       .                                  #[inline(always)]
       .                                  |i, j, depth| {
       .                                      lhs.read_unchecked(i, depth)
       .                                          .mul(&rhs.read_unchecked(depth, j))
       .                                  }
       .                              };
     388  (0.0%)                      small_gemm!(term);
       .                          }
       .                      }
       .                      return;
       .                  }
       .              }
       .          
       .              if use_gemm {
  93,188  (0.1%)          let gemm_parallelism = match parallelism {
       .                      Parallelism::None => gemm::Parallelism::None,
       .                      Parallelism::Rayon(0) => gemm::Parallelism::Rayon(rayon::current_num_threads()),
       .                      Parallelism::Rayon(n_threads) => gemm::Parallelism::Rayon(n_threads),
       .                  };
       .                  if coe::is_same::<f32, E>() {
       .                      let mut acc: MatMut<'_, f32> = coe::coerce(acc);
       .                      let a: MatRef<'_, f32> = coe::coerce(lhs);
       .                      let b: MatRef<'_, f32> = coe::coerce(rhs);
-- line 1741 ----------------------------------------
-- line 1768 ----------------------------------------
       .                  }
       .                  if coe::is_same::<f64, E>() {
       .                      let mut acc: MatMut<'_, f64> = coe::coerce(acc);
       .                      let a: MatRef<'_, f64> = coe::coerce(lhs);
       .                      let b: MatRef<'_, f64> = coe::coerce(rhs);
       .                      let alpha: Option<f64> = coe::coerce_static(alpha);
       .                      let beta: f64 = coe::coerce_static(beta);
       .                      unsafe {
       0                          gemm::gemm(
       .                              m,
       .                              n,
       .                              k,
       .                              acc.rb_mut().as_ptr(),
       .                              acc.col_stride(),
       .                              acc.row_stride(),
       .                              alpha.is_some(),
       .                              a.as_ptr(),
-- line 1784 ----------------------------------------
-- line 1986 ----------------------------------------
       .          ///     Parallelism::None,
       .          /// );
       .          ///
       .          /// zipped!(acc.as_ref(), target.as_ref())
       .          ///     .for_each(|acc, target| assert!((acc.read() - target.read()).abs() < 1e-10));
       .          /// ```
       .          #[inline]
       .          #[track_caller]
       0          pub fn matmul_with_conj<E: ComplexField>(
       .              acc: MatMut<'_, E>,
       .              lhs: MatRef<'_, E>,
       .              conj_lhs: Conj,
       .              rhs: MatRef<'_, E>,
       .              conj_rhs: Conj,
       .              alpha: Option<E>,
       .              beta: E,
       .              parallelism: Parallelism,
       .          ) {
       0              assert!(acc.nrows() == lhs.nrows());
       0              assert!(acc.ncols() == rhs.ncols());
       0              assert!(lhs.ncols() == rhs.nrows());
       .              matmul_with_conj_gemm_dispatch(
       .                  acc,
       .                  lhs,
       .                  conj_lhs,
       .                  rhs,
       .                  conj_rhs,
       .                  alpha,
       .                  beta,
       .                  parallelism,
       .                  true,
       .              );
       0          }
       .          
       .          /// Computes the matrix product `[alpha * acc] + beta * lhs * rhs` and
       .          /// stores the result in `acc`.
       .          ///
       .          /// Performs the operation:
       .          /// - `acc = beta * lhs * rhs` if `alpha` is `None` (in this case, the preexisting values in `acc`
       .          ///   are not read, so it is allowed to be a view over uninitialized values if `E: Copy`),
       .          /// - `acc = alpha * acc + beta * lhs * rhs` if `alpha` is `Some(_)`,
-- line 2026 ----------------------------------------
-- line 2069 ----------------------------------------
       .          pub fn matmul<E: ComplexField, LhsE: Conjugate<Canonical = E>, RhsE: Conjugate<Canonical = E>>(
       .              acc: MatMut<'_, E>,
       .              lhs: MatRef<'_, LhsE>,
       .              rhs: MatRef<'_, RhsE>,
       .              alpha: Option<E>,
       .              beta: E,
       .              parallelism: Parallelism,
       .          ) {
       8  (0.0%)      let (lhs, conj_lhs) = lhs.canonicalize();
       6  (0.0%)      let (rhs, conj_rhs) = rhs.canonicalize();
     -23 (-0.0%)      matmul_with_conj::<E>(acc, lhs, conj_lhs, rhs, conj_rhs, alpha, beta, parallelism);
       .          }
       .          
       .          macro_rules! stack_mat_16x16_begin {
       .              ($name: ident, $nrows: expr, $ncols: expr, $ty: ty) => {
       .                  let __nrows = $nrows;
       .                  let __ncols = $ncols;
       .                  let mut __data = <$ty as $crate::Entity>::map(
       .                      <$ty as $crate::Entity>::from_copy(<$ty as $crate::Entity>::UNIT),
-- line 2087 ----------------------------------------
-- line 2099 ----------------------------------------
       .                  <$ty as $crate::Entity>::map(
       .                      <$ty as $crate::Entity>::zip(
       .                          <$ty as $crate::Entity>::as_mut(&mut __data),
       .                          <$ty as $crate::Entity>::into_units(<$ty as $crate::ComplexField>::zero()),
       .                      ),
       .                      #[inline(always)]
       .                      |(__data, zero)| {
       .                          for __data in __data {
       0                              *__data = ::core::mem::MaybeUninit::new(::core::clone::Clone::clone(&zero));
       .                          }
       .                      },
       .                  );
       .                  let mut __data =
       .                      <$ty as $crate::Entity>::map(<$ty as $crate::Entity>::as_mut(&mut __data), |__data| {
       .                          (__data as *mut [::core::mem::MaybeUninit<<$ty as $crate::Entity>::Unit>; 16 * 16]
       .                              as *mut <$ty as $crate::Entity>::Unit)
       .                      });
-- line 2115 ----------------------------------------
-- line 2191 ----------------------------------------
       .                  alpha: Option<E>,
       .              ) {
       .                  let n = dst.nrows();
       .                  debug_assert!(n == dst.nrows());
       .                  debug_assert!(n == dst.ncols());
       .                  debug_assert!(n == src.nrows());
       .                  debug_assert!(n == src.ncols());
       .          
  -2,081 (-0.0%)          match alpha {
       .                      Some(alpha) => {
  10,405  (0.0%)                  zipped!(dst, src).for_each_triangular_lower(
       .                              if skip_diag { Diag::Skip } else { Diag::Include },
       .                              |mut dst, src| dst.write(alpha.mul(&dst.read().add(&src.read()))),
       .                          );
       .                      }
       .                      None => {
       .                          zipped!(dst, src).for_each_triangular_lower(
       .                              if skip_diag { Diag::Skip } else { Diag::Include },
       .                              |mut dst, src| dst.write(src.read()),
-- line 2209 ----------------------------------------
-- line 2227 ----------------------------------------
       .                  lhs: MatRef<'_, E>,
       .                  rhs: MatRef<'_, E>,
       .                  alpha: Option<E>,
       .                  beta: E,
       .                  conj_lhs: Conj,
       .                  conj_rhs: Conj,
       .                  parallelism: Parallelism,
       .              ) {
 -21,228 (-0.0%)          super::matmul_with_conj(dst, lhs, conj_lhs, rhs, conj_rhs, alpha, beta, parallelism);
       .              }
       .          
       .              unsafe fn mat_x_lower_into_lower_impl_unchecked<E: ComplexField>(
       .                  dst: MatMut<'_, E>,
       .                  skip_diag: bool,
       .                  lhs: MatRef<'_, E>,
       .                  rhs: MatRef<'_, E>,
       .                  rhs_diag: DiagonalKind,
-- line 2243 ----------------------------------------
-- line 2820 ----------------------------------------
       .                                  parallelism,
       .                              )
       .                          },
       .                          parallelism,
       .                      );
       .                  }
       .              }
       .          
       0              unsafe fn mat_x_mat_into_lower_impl_unchecked<E: ComplexField>(
       .                  dst: MatMut<'_, E>,
       .                  skip_diag: bool,
       .                  lhs: MatRef<'_, E>,
       .                  rhs: MatRef<'_, E>,
       .                  alpha: Option<E>,
       .                  beta: E,
       .                  conj_lhs: Conj,
       .                  conj_rhs: Conj,
-- line 2836 ----------------------------------------
-- line 2839 ----------------------------------------
       .                  debug_assert!(dst.nrows() == dst.ncols());
       .                  debug_assert!(dst.nrows() == lhs.nrows());
       .                  debug_assert!(dst.ncols() == rhs.ncols());
       .                  debug_assert!(lhs.ncols() == rhs.nrows());
       .          
       .                  let n = dst.nrows();
       .                  let k = lhs.ncols();
       .          
       0                  let join_parallelism = if n * n * k < 128 * 128 * 128 {
       .                      Parallelism::None
       .                  } else {
       0                      parallelism
       .                  };
       .          
       0                  if n <= 16 {
       .                      let op = {
       .                          #[inline(never)]
       0                          || {
       0                              stack_mat_16x16_begin!(temp_dst, n, n, E);
       .          
       .                              mul(
       .                                  temp_dst.rb_mut(),
       0                                  lhs,
       0                                  rhs,
       .                                  None,
       0                                  beta,
       0                                  conj_lhs,
       0                                  conj_rhs,
       0                                  parallelism,
       .                              );
  -6,243 (-0.0%)                      accum_lower(dst, temp_dst.rb(), skip_diag, alpha);
       .          
       .                              stack_mat_16x16_end!(temp_dst, n, n, E);
       0                          }
       .                      };
       0                      op();
       .                  } else {
       0                      let bs = n / 2;
       0                      let [dst_top_left, _, dst_bot_left, dst_bot_right] = dst.split_at(bs, bs);
       0                      let [lhs_top, lhs_bot] = lhs.split_at_row(bs);
       0                      let [rhs_left, rhs_right] = rhs.split_at_col(bs);
       .          
       .                      join_raw(
       .                          |_| {
       .                              mul(
   1,793  (0.0%)                          dst_bot_left,
  10,758  (0.0%)                          lhs_bot,
  12,551  (0.0%)                          rhs_left,
   1,793  (0.0%)                          alpha.clone(),
   1,793  (0.0%)                          beta.clone(),
   1,793  (0.0%)                          conj_lhs,
   1,793  (0.0%)                          conj_rhs,
   1,793  (0.0%)                          parallelism,
       .                              )
       .                          },
       .                          |_| {
       .                              join_raw(
       .                                  |_| {
  -1,793 (-0.0%)                              mat_x_mat_into_lower_impl_unchecked(
   1,793  (0.0%)                                  dst_top_left,
       0                                          skip_diag,
   1,793  (0.0%)                                  lhs_top,
   1,793  (0.0%)                                  rhs_left,
   1,793  (0.0%)                                  alpha.clone(),
   1,793  (0.0%)                                  beta.clone(),
   1,793  (0.0%)                                  conj_lhs,
   1,793  (0.0%)                                  conj_rhs,
   1,793  (0.0%)                                  parallelism,
       .                                      )
       .                                  },
       .                                  |_| {
  -1,793 (-0.0%)                              mat_x_mat_into_lower_impl_unchecked(
   1,793  (0.0%)                                  dst_bot_right,
       0                                          skip_diag,
   1,793  (0.0%)                                  lhs_bot,
   1,793  (0.0%)                                  rhs_right,
   1,793  (0.0%)                                  alpha.clone(),
   1,793  (0.0%)                                  beta.clone(),
   1,793  (0.0%)                                  conj_lhs,
   1,793  (0.0%)                                  conj_rhs,
   1,793  (0.0%)                                  parallelism,
       .                                      )
       .                                  },
       0                                  join_parallelism,
       .                              )
       .                          },
       .                          join_parallelism,
       .                      );
       .                  }
       0              }
       .          
       .              #[derive(Debug, Clone, Copy)]
       .              pub enum BlockStructure {
       .                  Rectangular,
       .                  TriangularLower,
       .                  StrictTriangularLower,
       .                  UnitTriangularLower,
       .                  TriangularUpper,
-- line 2936 ----------------------------------------
-- line 3073 ----------------------------------------
       .                  conj_lhs: Conj,
       .                  rhs: MatRef<'_, E>,
       .                  rhs_structure: BlockStructure,
       .                  conj_rhs: Conj,
       .                  alpha: Option<E>,
       .                  beta: E,
       .                  parallelism: Parallelism,
       .              ) {
       0                  assert!(acc.nrows() == lhs.nrows());
       0                  assert!(acc.ncols() == rhs.ncols());
       0                  assert!(lhs.ncols() == rhs.nrows());
       .          
       .                  if !acc_structure.is_dense() {
       0                      assert!(acc.nrows() == acc.ncols());
       .                  }
       .                  if !lhs_structure.is_dense() {
       .                      assert!(lhs.nrows() == lhs.ncols());
       .                  }
       .                  if !rhs_structure.is_dense() {
       .                      assert!(rhs.nrows() == rhs.ncols());
       .                  }
       .          
       .                  unsafe {
       .                      matmul_unchecked(
       0                          acc,
       .                          acc_structure,
       .                          lhs,
       .                          lhs_structure,
       .                          conj_lhs,
       .                          rhs,
       .                          rhs_structure,
       .                          conj_rhs,
       .                          alpha,
-- line 3105 ----------------------------------------
-- line 3174 ----------------------------------------
       .              ///     Parallelism::None,
       .              /// );
       .              ///
       .              /// zipped!(acc.as_ref(), target.as_ref())
       .              ///     .for_each(|acc, target| assert!((acc.read() - target.read()).abs() < 1e-10));
       .              /// ```
       .              #[track_caller]
       .              #[inline]
       0              pub fn matmul<
       .                  E: ComplexField,
       .                  LhsE: Conjugate<Canonical = E>,
       .                  RhsE: Conjugate<Canonical = E>,
       .              >(
       .                  acc: MatMut<'_, E>,
       .                  acc_structure: BlockStructure,
       .                  lhs: MatRef<'_, LhsE>,
       .                  lhs_structure: BlockStructure,
       .                  rhs: MatRef<'_, RhsE>,
       .                  rhs_structure: BlockStructure,
       .                  alpha: Option<E>,
       .                  beta: E,
       .                  parallelism: Parallelism,
       .              ) {
  -1,152 (-0.0%)          let (lhs, conj_lhs) = lhs.canonicalize();
  -1,152 (-0.0%)          let (rhs, conj_rhs) = rhs.canonicalize();
       .                  matmul_with_conj(
       .                      acc,
       .                      acc_structure,
       .                      lhs,
       .                      lhs_structure,
       .                      conj_lhs,
       .                      rhs,
       .                      rhs_structure,
       .                      conj_rhs,
       .                      alpha,
       .                      beta,
       .                      parallelism,
       .                  );
       0              }
       .          
       .              unsafe fn matmul_unchecked<E: ComplexField>(
       .                  acc: MatMut<'_, E>,
       .                  acc_structure: BlockStructure,
       .                  lhs: MatRef<'_, E>,
       .                  lhs_structure: BlockStructure,
       .                  conj_lhs: Conj,
       .                  rhs: MatRef<'_, E>,
-- line 3220 ----------------------------------------
-- line 3353 ----------------------------------------
       .                                  conj_lhs,
       .                                  conj_rhs,
       .                                  parallelism,
       .                              )
       .                          }
       .                      }
       .                  } else if acc_structure.is_lower() {
       .                      if lhs_structure.is_dense() && rhs_structure.is_dense() {
       0                          mat_x_mat_into_lower_impl_unchecked(
       0                              acc,
       .                              skip_diag,
       0                              lhs,
       0                              rhs,
       .                              alpha,
       .                              beta,
       .                              conj_lhs,
       .                              conj_rhs,
       .                              parallelism,
       .                          )
       .                      } else {
       .                          debug_assert!(rhs_structure.is_lower());
-- line 3373 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/faer-core-0.11.0/src/solve.rs
--------------------------------------------------------------------------------
Ir________________ 

  -774,646 (-0.7%)  <unknown (line 0)>

-- line 100 ----------------------------------------
         .          
         .          #[inline(always)]
         .          unsafe fn solve_lower_triangular_in_place_base_case_generic_unchecked<E: ComplexField>(
         .              tril: MatRef<'_, E>,
         .              rhs: MatMut<'_, E>,
         .              maybe_conj_lhs: impl Fn(E) -> E,
         .          ) {
         .              let n = tril.nrows();
         0              match n {
         .                  0 => (),
         .                  1 => {
         .                      let inv = maybe_conj_lhs(tril.read_unchecked(0, 0)).inv();
         .                      let x0 = rhs.subrows(0, 1);
         .                      x0.cwise().for_each(|mut x0| x0.write(x0.read().mul(&inv)));
         .                  }
         .                  2 => {
         .                      let l00_inv = maybe_conj_lhs(tril.read_unchecked(0, 0)).inv();
-- line 116 ----------------------------------------
-- line 203 ----------------------------------------
         .                  _ => unreachable!(),
         .              }
         .          }
         .          
         .          #[inline]
         .          fn blocksize(n: usize) -> usize {
         .              // we want remainder to be a multiple of register size
         .          
      -129 (-0.0%)      let base_rem = n / 2;
       258  (0.0%)      n - if n >= 32 {
    19,955  (0.0%)          (base_rem + 15) / 16 * 16
         0              } else if n >= 16 {
         0                  (base_rem + 7) / 8 * 8
         0              } else if n >= 8 {
   -48,426 (-0.0%)          (base_rem + 3) / 4 * 4
         .              } else {
         .                  base_rem
         .              }
         .          }
         .          
         .          #[inline]
         .          fn recursion_threshold() -> usize {
         .              4
-- line 225 ----------------------------------------
-- line 273 ----------------------------------------
         .          ///     Parallelism::None,
         .          /// );
         .          ///
         .          /// zipped!(m_times_sol.as_ref(), rhs.as_ref())
         .          ///     .for_each(|x, target| assert!((x.read() - target.read()).abs() < 1e-10));
         .          /// ```
         .          #[track_caller]
         .          #[inline]
         0          pub fn solve_lower_triangular_in_place_with_conj<E: ComplexField>(
         .              triangular_lower: MatRef<'_, E>,
         .              conj_lhs: Conj,
         .              rhs: MatMut<'_, E>,
         .              parallelism: Parallelism,
         .          ) {
         0              assert!(triangular_lower.nrows() == triangular_lower.ncols());
         0              assert!(rhs.nrows() == triangular_lower.ncols());
         .          
         .              unsafe {
    -1,734 (-0.0%)          solve_lower_triangular_in_place_unchecked(triangular_lower, conj_lhs, rhs, parallelism);
         .              }
         0          }
         .          
         .          #[track_caller]
         .          #[inline]
         .          pub fn solve_lower_triangular_in_place<E: ComplexField, TriE: Conjugate<Canonical = E>>(
         .              triangular_lower: MatRef<'_, TriE>,
         .              rhs: MatMut<'_, E>,
         .              parallelism: Parallelism,
         .          ) {
     1,440  (0.0%)      let (tri, conj) = triangular_lower.canonicalize();
    -1,440 (-0.0%)      solve_lower_triangular_in_place_with_conj(tri, conj, rhs, parallelism)
         .          }
         .          
         .          /// Computes the solution of `Op_lhs(triangular_upper)×X = rhs`, and stores the result in
         .          /// `rhs`.
         .          ///
         .          /// `triangular_upper` is interpreted as a upper triangular matrix (diagonal included).
         .          /// Its strictly lower triangular part is not accessed.
         .          ///
-- line 311 ----------------------------------------
-- line 662 ----------------------------------------
         .          
         .          /// # Safety
         .          ///
         .          /// Same as [`solve_lower_triangular_in_place`], except that panics become undefined behavior.
         .          ///
         .          /// # Example
         .          ///
         .          /// See [`solve_lower_triangular_in_place`].
   193,546  (0.2%)  unsafe fn solve_lower_triangular_in_place_unchecked<E: ComplexField>(
         .              tril: MatRef<'_, E>,
         .              conj_lhs: Conj,
         .              rhs: MatMut<'_, E>,
         .              parallelism: Parallelism,
         .          ) {
         .              let n = tril.nrows();
         .              let k = rhs.ncols();
         .          
   185,098  (0.2%)      if k > 64 && n <= 128 {
         0                  let [_, _, rhs_left, rhs_right] = rhs.split_at(0, k / 2);
         .                  join_raw(
     3,840  (0.0%)              |_| solve_lower_triangular_in_place_unchecked(tril, conj_lhs, rhs_left, parallelism),
     3,840  (0.0%)              |_| solve_lower_triangular_in_place_unchecked(tril, conj_lhs, rhs_right, parallelism),
         .                      parallelism,
         .                  );
         .                  return;
         .              }
         .          
         .              debug_assert!(tril.nrows() == tril.ncols());
         .              debug_assert!(rhs.nrows() == tril.ncols());
         .          
         .              let n = tril.nrows();
         .          
       258  (0.0%)      if n <= recursion_threshold() {
         .                  pulp::Arch::new().dispatch(
         .                      #[inline(always)]
   387,672  (0.4%)              || match conj_lhs {
         .                          Conj::Yes => {
         .                              solve_lower_triangular_in_place_base_case_generic_unchecked(tril, rhs, conj)
         .                          }
         .                          Conj::No => {
         .                              solve_lower_triangular_in_place_base_case_generic_unchecked(tril, rhs, identity)
         .                          }
         .                      },
         .                  );
         .                  return;
         .              }
         .          
         .              let bs = blocksize(n);
         .          
 1,391,820  (1.3%)      let [tril_top_left, _, tril_bot_left, tril_bot_right] = tril.split_at(bs, bs);
         0              let [_, mut rhs_top, _, mut rhs_bot] = rhs.split_at(bs, 0);
         .          
  -185,576 (-0.2%)      solve_lower_triangular_in_place_unchecked(
         .                  tril_top_left,
         .                  conj_lhs,
         .                  rhs_top.rb_mut(),
         .                  parallelism,
         .              );
         .          
-1,020,668 (-0.9%)      crate::mul::matmul_with_conj(
         .                  rhs_bot.rb_mut(),
         .                  tril_bot_left,
    92,788  (0.1%)          conj_lhs,
         .                  rhs_top.into_const(),
         .                  Conj::No,
         .                  Some(E::one()),
         .                  E::one().neg(),
         .                  parallelism,
         .              );
         .          
  -927,880 (-0.9%)      solve_lower_triangular_in_place_unchecked(tril_bot_right, conj_lhs, rhs_bot, parallelism);
         0          }
         .          
         .          /// # Safety
         .          ///
         .          /// Same as [`solve_upper_triangular_in_place`], except that panics become undefined behavior.
         .          ///
         .          /// # Example
         .          ///
         .          /// See [`solve_upper_triangular_in_place`].
         .          #[inline]
         .          unsafe fn solve_upper_triangular_in_place_unchecked<E: ComplexField>(
         .              triu: MatRef<'_, E>,
         .              conj_lhs: Conj,
         .              rhs: MatMut<'_, E>,
         .              parallelism: Parallelism,
         .          ) {
         0              solve_lower_triangular_in_place_unchecked(
         .                  triu.reverse_rows_and_cols(),
         .                  conj_lhs,
         .                  rhs.reverse_rows(),
         .                  parallelism,
         .              );
         .          }

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/gemm.rs
--------------------------------------------------------------------------------
Ir__________________ 

-23,054,628 (-21.2%)  <unknown (line 0)>

-- line 52 ----------------------------------------
          .               )))]
          .               {
          .                   64
          .               }
          .           };
          .           
          .           thread_local! {
          .               pub static L2_SLAB: RefCell<GlobalMemBuffer> = RefCell::new(GlobalMemBuffer::new(
          0                   StackReq::new_aligned::<u8>(CACHE_INFO[1].cache_bytes, CACHELINE_ALIGN)
          .               ));
          .           }
          .           
          .           pub trait Conj: Copy {
          .               fn conj(self) -> Self;
          .           }
          .           
          .           impl Conj for f32 {
-- line 68 ----------------------------------------
-- line 190 ----------------------------------------
          .               beta: T,
          .               conj_dst: bool,
          .               conj_lhs: bool,
          .               conj_rhs: bool,
          .               mul_add: impl Copy + Fn(T, T, T) -> T,
          .               dispatcher: &[[MicroKernelFn<T>; NR]; MR_DIV_N],
          .               parallelism: Parallelism,
          .           ) {
          0               if m == 0 || n == 0 {
          .                   return;
          .               }
          0               if !read_dst {
          .                   alpha.set_zero();
          .               }
          .           
     93,188   (0.1%)      if k == 0 {
          .                   // dst = alpha * conj?(dst)
          .           
          .                   if alpha.is_zero() {
          .                       for j in 0..n {
          .                           for i in 0..m {
          .                               *dst.offset(i as isize * dst_rs + j as isize * dst_cs) = T::zero();
          .                           }
          .                       }
-- line 213 ----------------------------------------
-- line 231 ----------------------------------------
          .                               let dst = dst.offset(i as isize * dst_rs + j as isize * dst_cs);
          .                               *dst = alpha * *dst;
          .                           }
          .                       }
          .                   }
          .                   return;
          .               }
          .           
    -93,188  (-0.1%)      if !conj_dst && !conj_lhs && !conj_rhs {
          0                   if k <= 2 {
          .                       gevv::gevv(
          .                           simd, m, n, k, dst, dst_cs, dst_rs, lhs, lhs_cs, lhs_rs, rhs, rhs_cs, rhs_rs,
          .                           alpha, beta, mul_add,
          .                       );
          .                       return;
          .                   }
          0                   if m <= 1 && rhs_cs.unsigned_abs() <= rhs_rs.unsigned_abs() {
          .                       gemv::gemv(
          .                           simd, n, m, k, dst, dst_rs, dst_cs, rhs, rhs_rs, rhs_cs, lhs, lhs_rs, lhs_cs,
          .                           alpha, beta, mul_add,
          .                       );
          .                       return;
          .                   }
          0                   if n <= 1 && lhs_rs.unsigned_abs() <= lhs_cs.unsigned_abs() {
          .                       gemv::gemv(
          .                           simd, m, n, k, dst, dst_cs, dst_rs, lhs, lhs_cs, lhs_rs, rhs, rhs_cs, rhs_rs,
          .                           alpha, beta, mul_add,
          .                       );
          .                       return;
          .                   }
          .               }
          .           
          0               let KernelParams { kc, mc, nc } = if m <= 64 && n <= 64 {
          .                   // skip expensive kernel_params call for small sizes
          .                   let kc = k.min(512);
          0                   let alloc = CACHE_INFO[1].cache_bytes / core::mem::size_of::<T>();
          0                   let mc = (alloc / kc) / MR * MR;
          .           
          .                   KernelParams {
          .                       kc,
          .                       mc,
    -92,898  (-0.1%)              nc: div_ceil(n, NR) * NR,
          .                   }
          .               } else {
          0                   kernel_params(m, n, k, MR, NR, core::mem::size_of::<T>())
          .               };
          0               let nc = if nc > 0 {
          .                   nc
          .               } else {
          .                   match parallelism {
          .                       Parallelism::None => 128 * NR,
          .                       Parallelism::Rayon(_) => div_ceil(n, NR) * NR,
          .                   }
          .               };
          .           
          .               let simd_align = CACHELINE_ALIGN;
          .           
          0               let packed_rhs_stride = kc * NR;
          .               let packed_lhs_stride = kc * MR;
          .           
          .               let dst = Ptr(dst);
          .               let lhs = Ptr(lhs as *mut T);
     93,156   (0.1%)      let rhs = Ptr(rhs as *mut T);
          .           
          .               #[cfg(target_arch = "aarch64")]
          .               let do_pack_rhs = m > get_rhs_packing_threshold() * MR;
          .           
          .               // no need to pack if the lhs is already contiguous-ish
          .               #[cfg(not(target_arch = "aarch64"))]
    -96,614  (-0.1%)      let do_pack_rhs = (rhs_rs.unsigned_abs() != 1 && m > 2 * MR)
      3,458   (0.0%)          || (rhs_rs.unsigned_abs() == 1 && m > get_rhs_packing_threshold() * MR);
          .           
     -3,458  (-0.0%)      let mut mem = if do_pack_rhs {
          0                   Some(GlobalMemBuffer::new(StackReq::new_aligned::<T>(
          0                       packed_rhs_stride * (nc / NR),
          .                       simd_align,
          .                   )))
          .               } else {
     -3,458  (-0.0%)          None
          .               };
          .           
          .               let mut packed_rhs_storage = mem.as_mut().map(|mem| {
          .                   let stack = DynStack::new(mem);
   -179,396  (-0.2%)          stack
          .                       .make_aligned_uninit::<T>(packed_rhs_stride * (nc / NR), simd_align)
          .                       .0
          .               });
          .           
          .               let packed_rhs = packed_rhs_storage
          .                   .as_mut()
          .                   .map(|storage| storage.as_mut_ptr() as *mut T)
          .                   .unwrap_or(core::ptr::null_mut());
          0               let packed_rhs = Ptr(packed_rhs);
          .           
          .               let packed_rhs_rs = if do_pack_rhs { NR as isize } else { rhs_rs };
          .               let packed_rhs_cs = if do_pack_rhs { 1 } else { rhs_cs };
          .           
          0               let mut col_outer = 0;
          0               while col_outer != n {
          0                   let n_chunk = nc.min(n - col_outer);
          .           
          .                   let mut alpha = alpha;
          .                   let mut conj_dst = conj_dst;
          .           
          0                   let mut depth_outer = 0;
          0                   while depth_outer != k {
          0                       let k_chunk = kc.min(k - depth_outer);
          0                       let alpha_status = if alpha.is_zero() {
          .                           0
          .                       } else if alpha.is_one() {
          .                           1
          .                       } else {
          .                           2
          .                       };
          .           
          0                       let n_threads = match parallelism {
          .                           Parallelism::None => 1,
          .                           Parallelism::Rayon(n_threads) => {
          .                               let threading_threshold = get_threading_threshold();
          0                               if m * n_chunk * k_chunk <= threading_threshold {
          .                                   1
          .                               } else {
          0                                   if n_threads == 0 {
          .                                       rayon::current_num_threads()
          .                                   } else {
          .                                       n_threads
          .                                   }
          .                               }
          .                           }
          .                       };
          .           
          0                       if do_pack_rhs {
          0                           if n_threads <= 1 {
          0                               pack_rhs::<T, 1, NR, _>(
          .                                   simd,
          .                                   n_chunk,
          0                                   k_chunk,
          0                                   packed_rhs,
          .                                   rhs.wrapping_offset(
          0                                       depth_outer as isize * rhs_rs + col_outer as isize * rhs_cs,
          .                                   ),
          .                                   rhs_cs,
          .                                   rhs_rs,
          0                                   packed_rhs_stride,
          .                               );
          .                           } else {
          .                               let n_tasks = div_ceil(n_chunk, NR);
          0                               let base = n_tasks / n_threads;
          0                               let rem = n_tasks % n_threads;
          .           
          0                               let tid_to_col_inner = |tid: usize| {
          0                                   if tid == n_threads {
          .                                       return n_chunk;
          .                                   }
          .           
          0                                   let col = if tid < rem {
          0                                       NR * tid * (base + 1)
          .                                   } else {
          0                                       NR * (rem + tid * base)
          .                                   };
          0                                   col.min(n_chunk)
          .                               };
          .           
    -16,640  (-0.0%)                      let func = |tid: usize| {
          0                                   let col_inner = tid_to_col_inner(tid);
          0                                   let ncols = tid_to_col_inner(tid + 1) - col_inner;
          0                                   let j = col_inner / NR;
          .           
     30,016   (0.0%)                          if ncols > 0 {
          0                                       pack_rhs::<T, 1, NR, _>(
          .                                           simd,
          .                                           ncols,
          0                                           k_chunk,
          0                                           packed_rhs.wrapping_add(j * packed_rhs_stride),
          0                                           rhs.wrapping_offset(
          0                                               depth_outer as isize * rhs_rs
          0                                                   + (col_outer + col_inner) as isize * rhs_cs,
          .                                           ),
          .                                           rhs_cs,
          .                                           rhs_rs,
          .                                           packed_rhs_stride,
          .                                       );
          .                                   }
     -3,264  (-0.0%)                      };
    -16,640  (-0.0%)                      par_for_each(n_threads, func);
          .                           }
          .                       }
          .           
     96,994   (0.1%)              let n_col_mini_chunks = (n_chunk + (NR - 1)) / NR;
          .           
          .                       let mut n_jobs = 0;
          .                       let mut row_outer = 0;
          0                       while row_outer != m {
          0                           let mut m_chunk = mc.min(m - row_outer);
          0                           if m_chunk > N {
          .                               m_chunk = m_chunk / N * N;
          .                           }
          0                           let n_row_mini_chunks = (m_chunk + (MR - 1)) / MR;
          0                           n_jobs += n_col_mini_chunks * n_row_mini_chunks;
          0                           row_outer += m_chunk;
          .                       }
          .           
          .                       // use a single thread for small workloads
          .           
          0                       let func = move |tid| {
          0                           L2_SLAB.with(|mem| {
          .                               let mut mem = mem.borrow_mut();
          .                               let stack = DynStack::new(&mut **mem);
          .           
          .                               let (mut packed_lhs_storage, _) =
   -112,802  (-0.1%)                          stack.make_aligned_uninit::<T>(packed_lhs_stride * (mc / MR), simd_align);
          .           
          .                               let packed_lhs = Ptr(packed_lhs_storage.as_mut_ptr() as *mut T);
          .           
   -112,802  (-0.1%)                      let min_jobs_per_thread = n_jobs / n_threads;
   -338,406  (-0.3%)                      let rem = n_jobs - n_threads * min_jobs_per_thread;
          .           
          .                               // thread `tid` takes min_jobs_per_thread or min_jobs_per_thread + 1
          0                               let (job_start, job_end) = if tid < rem {
          0                                   let start = tid * (min_jobs_per_thread + 1);
      6,481   (0.0%)                          (start, start + min_jobs_per_thread + 1)
          .                               } else {
          .                                   // start = rem * (min_jobs_per_thread + 1) + (tid - rem) * min_jobs_per_thread;
          0                                   let start = tid * min_jobs_per_thread + rem;
          0                                   (start, start + min_jobs_per_thread)
          .                               };
          .           
          .                               let mut row_outer = 0;
          .                               let mut job_id = 0;
          0                               while row_outer != m {
          0                                   let mut m_chunk = mc.min(m - row_outer);
          0                                   if m_chunk > N {
          .                                       m_chunk = m_chunk / N * N;
          .                                   }
          0                                   let n_row_mini_chunks = (m_chunk + (MR - 1)) / MR;
          .           
          0                                   let n_mini_jobs = n_col_mini_chunks * n_row_mini_chunks;
          .           
  1,240,822   (1.1%)                          if job_id >= job_end {
          .                                       return;
          .                                   }
          0                                   if job_id + n_mini_jobs < job_start {
          .                                       row_outer += m_chunk;
          .                                       job_id += n_mini_jobs;
          .                                       continue;
          .                                   }
          .           
          .                                   let packing_threshold = if n_threads == 1 {
          .                                       get_lhs_packing_threshold_single_thread()
          .                                   } else {
          .                                       get_lhs_packing_threshold_multi_thread()
          .                                   };
          .                                   let do_pack_lhs =
   -764,616  (-0.7%)                              (m_chunk % N != 0) || lhs_rs != 1 || n_chunk > packing_threshold * NR;
          .                                   let packed_lhs_cs = if do_pack_lhs { MR as isize } else { lhs_cs };
          .           
          .                                   if do_pack_lhs {
    -94,806  (-0.1%)                              pack_lhs::<T, N, MR, _>(
          .                                           simd,
          .                                           m_chunk,
          .                                           k_chunk,
          .                                           packed_lhs,
          .                                           lhs.wrapping_offset(
          0                                               row_outer as isize * lhs_rs + depth_outer as isize * lhs_cs,
          .                                           ),
          .                                           lhs_cs,
          .                                           lhs_rs,
          .                                           packed_lhs_stride,
          .                                       );
          .                                   }
          .           
          .                                   let mut j = 0;
    260,287   (0.2%)                          while j < n_col_mini_chunks {
          .                                       let mut i = 0;
 27,369,284  (25.2%)                              while i < n_row_mini_chunks {
          .                                           let col_inner = NR * j;
          .                                           let n_chunk_inner = NR.min(n_chunk - col_inner);
          .           
 11,950,378  (11.0%)                                  let row_inner = MR * i;
-11,950,378 (-11.0%)                                  let m_chunk_inner = MR.min(m_chunk - row_inner);
          .           
          .                                           let inner_idx = &mut i;
 -1,632,180  (-1.5%)                                  if job_id < job_start || job_id >= job_end {
          .                                               job_id += 1;
          .                                               *inner_idx += 1;
          .                                               continue;
          .                                           }
          .                                           job_id += 1;
          .           
          .                                           let dst = dst.wrapping_offset(
-11,246,547 (-10.4%)                                      (row_outer + row_inner) as isize * dst_rs
          .                                                   + (col_outer + col_inner) as isize * dst_cs,
          .                                           );
          .           
  3,748,849   (3.5%)                                  let func = dispatcher[(m_chunk_inner + (N - 1)) / N - 1]
          .                                               [n_chunk_inner - 1];
          .           
 14,995,396  (13.8%)                                  func(
          .                                               m_chunk_inner,
          .                                               n_chunk_inner,
          .                                               k_chunk,
          .                                               dst.0,
-41,237,339 (-38.0%)                                      if do_pack_lhs {
          .                                                   packed_lhs.wrapping_add(i * packed_lhs_stride).0
          .                                               } else {
          .                                                   lhs.wrapping_offset(
    910,856   (0.8%)                                              (row_outer + row_inner) as isize * lhs_rs
          .                                                           + depth_outer as isize * lhs_cs,
          .                                                   )
          .                                                   .0
          .                                               },
          .                                               if do_pack_rhs {
          .                                                   packed_rhs.wrapping_add(j * packed_rhs_stride).0
          .                                               } else {
          .                                                   rhs.wrapping_offset(
-- line 545 ----------------------------------------
-- line 554 ----------------------------------------
          .                                               packed_rhs_rs,
          .                                               packed_rhs_cs,
          .                                               alpha,
          .                                               beta,
          .                                               alpha_status,
          .                                               conj_dst,
          .                                               conj_lhs,
          .                                               conj_rhs,
-25,225,662 (-23.2%)                                      if do_pack_lhs {
          .                                                   packed_lhs.wrapping_add((i + 1) * packed_lhs_stride).0
          .                                               } else {
          .                                                   lhs.wrapping_offset(
          .                                                       (row_outer + row_inner + m_chunk_inner) as isize
          .                                                           * lhs_rs
          .                                                           + depth_outer as isize * lhs_cs,
          .                                                   )
          .                                                   .0
          .                                               },
          .                                           );
          .                                           i += 1;
          .                                       }
          0                                       j += 1;
          .                                   }
          .           
          .                                   row_outer += m_chunk;
          .                               }
   -112,802  (-0.1%)                  });
          0                       };
          .           
          0                       match parallelism {
          .                           Parallelism::None => func(0),
          .                           Parallelism::Rayon(_) => {
          .                               if n_threads == 1 {
          .                                   func(0);
          .                               } else {
          0                                   par_for_each(n_threads, func);
          .                               }
          .                           }
          .                       }
          .           
          .                       conj_dst = false;
          .                       alpha.set_one();
          .           
          0                       depth_outer += k_chunk;
          .                   }
          0                   col_outer += n_chunk;
          .               }
          .           }
          .           
          .           #[macro_export]
          .           macro_rules! __inject_mod {
          .               ($module: ident, $ty: ident, $N: expr, $simd: ident) => {
          .                   mod $module {
          .                       use super::*;
          .                       use crate::microkernel::$module::$ty::*;
          .                       const N: usize = $N;
          .           
          .                       #[inline(never)]
          0                       pub unsafe fn gemm_basic(
          .                           m: usize,
          .                           n: usize,
          .                           k: usize,
          .                           dst: *mut T,
          .                           dst_cs: isize,
          .                           dst_rs: isize,
          .                           read_dst: bool,
          .                           lhs: *const T,
-- line 620 ----------------------------------------
-- line 645 ----------------------------------------
          .                               rhs,
          .                               rhs_cs,
          .                               rhs_rs,
          .                               alpha,
          .                               beta,
          .                               conj_dst,
          .                               conj_lhs,
          .                               conj_rhs,
          0                               |a, b, c| a * b + c,
          .                               &UKR,
          .                               parallelism,
          .                           );
          0                       }
          .                   }
          .               };
          .           }
          .           
          .           #[macro_export]
          .           macro_rules! __inject_mod_cplx {
          .               ($module: ident, $ty: ident, $N: expr, $simd: ident) => {
          .                   paste::paste! {
-- line 665 ----------------------------------------
-- line 744 ----------------------------------------
          .                       bool,
          .                       $crate::Parallelism,
          .                   );
          .           
          .                   fn init_gemm_fn() -> GemmTy {
          .                       #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
          .                       {
          .                           #[cfg(feature = "nightly")]
          1   (0.0%)                  if $crate::feature_detected!("avx512f") {
          .                               return avx512f::gemm_basic;
          .                           }
          0                           if $crate::feature_detected!("fma") {
          .                               fma::gemm_basic
          .                           } else if $crate::feature_detected!("avx") {
          .                               avx::gemm_basic
          .                           } else if $crate::feature_detected!("sse") && $crate::feature_detected!("sse2") {
          .                               sse::gemm_basic
          .                           } else {
          .                               scalar::gemm_basic
          .                           }
-- line 763 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/microkernel.rs
--------------------------------------------------------------------------------
Ir__________________ 

 -8,104,334  (-7.5%)  <unknown (line 0)>

-- line 109 ----------------------------------------
          .           }
          .           
          .           #[macro_export]
          .           macro_rules! microkernel {
          .               ($([$target: tt])?, $unroll: tt, $name: ident, $mr_div_n: tt, $nr: tt $(, $nr_div_n: tt, $n: tt)?) => {
          .                   #[inline]
          .                   $(#[target_feature(enable = $target)])?
          .                   // 0, 1, or 2 for generic alpha
 -6,910,318  (-6.4%)          pub unsafe fn $name(
          .                       m: usize,
          .                       n: usize,
          .                       k: usize,
          .                       dst: *mut T,
          .                       mut packed_lhs: *const T,
          .                       mut packed_rhs: *const T,
          .                       dst_cs: isize,
          .                       dst_rs: isize,
-- line 125 ----------------------------------------
-- line 156 ----------------------------------------
          .                       impl KernelIter {
          .                           #[inline(always)]
          .                           unsafe fn execute(self, iter: usize) {
          .                               let packed_lhs = self.packed_lhs.wrapping_offset(iter as isize * self.lhs_cs);
          .                               let packed_rhs = self.packed_rhs.wrapping_offset(iter as isize * self.rhs_rs);
          .                               let next_lhs = self.next_lhs.wrapping_offset(iter as isize * self.lhs_cs);
          .           
          .                               seq_macro::seq!(M_ITER in 0..$mr_div_n {{
          0                                   *self.lhs.add(M_ITER) = (packed_lhs.add(M_ITER * N) as *const Pack).read_unaligned();
          .                               }});
          .           
          .                               seq_macro::seq!(N_ITER in 0..$nr {{
          0                                   *self.rhs = splat(*packed_rhs.wrapping_offset(N_ITER * self.rhs_cs));
          .                                   let accum = self.accum.add(N_ITER * $mr_div_n);
          .                                   seq_macro::seq!(M_ITER in 0..$mr_div_n {{
          .                                       let accum = &mut *accum.add(M_ITER);
          .                                       *accum = mul_add(
          .                                           *self.lhs.add(M_ITER),
          .                                           *self.rhs,
          .                                           *accum,
          .                                           );
-- line 176 ----------------------------------------
-- line 206 ----------------------------------------
          .                                                   );
          .                                           }});
          .                                       }});
          .                                   }});
          .                               }
          .                           )?
          .                       }
          .           
 -3,446,133  (-3.2%)              let k_unroll = k / $unroll;
          .                       let k_leftover = k % $unroll;
          .           
          .                       loop {
          .                           $(
          .                           let _ = $nr_div_n;
          .                           if rhs_cs == 1 {
          .                               let mut depth = k_unroll;
          .                               if depth != 0 {
-- line 222 ----------------------------------------
-- line 273 ----------------------------------------
          .                                       }
          .                                   }
          .                               }
          .                               break;
          .                           }
          .                           )?
          .           
          .                           let mut depth = k_unroll;
  3,450,076   (3.2%)                  if depth != 0 {
          .                               loop {
          .                                   let iter = KernelIter {
          .                                       packed_lhs,
          .                                       next_lhs,
          .                                       packed_rhs,
          .                                       lhs_cs,
          .                                       rhs_rs,
          .                                       rhs_cs,
-- line 289 ----------------------------------------
-- line 295 ----------------------------------------
          .                                   seq_macro::seq!(UNROLL_ITER in 0..$unroll {{
          .                                       iter.execute(UNROLL_ITER);
          .                                   }});
          .           
          .                                   packed_lhs = packed_lhs.wrapping_offset($unroll * lhs_cs);
          .                                   packed_rhs = packed_rhs.wrapping_offset($unroll * rhs_rs);
          .                                   next_lhs = next_lhs.wrapping_offset($unroll * lhs_cs);
          .           
          0                                   depth -= 1;
530,460,513 (488.4%)                          if depth == 0 {
          .                                       break;
          .                                   }
          .                               }
          .                           }
          .                           depth = k_leftover;
          0                           if depth != 0 {
          .                               loop {
          .                                   KernelIter {
          .                                       packed_lhs,
          .                                       next_lhs,
          .                                       packed_rhs,
          .                                       lhs_cs,
          .                                       rhs_rs,
          .                                       rhs_cs,
-- line 318 ----------------------------------------
-- line 330 ----------------------------------------
          .                                   if depth == 0 {
          .                                       break;
          .                                   }
          .                               }
          .                           }
          .                           break;
          .                       }
          .           
          0                       if m == $mr_div_n * N && n == $nr && dst_rs == 1  {
          .                           let alpha = splat(alpha);
          .                           let beta = splat(beta);
          0                           if alpha_status == 2 {
          .                               seq_macro::seq!(N_ITER in 0..$nr {{
          .                                   seq_macro::seq!(M_ITER in 0..$mr_div_n {{
          .                                       let dst = dst.offset(M_ITER * N as isize + N_ITER * dst_cs) as *mut Pack;
          .                                       dst.write_unaligned(add(
          .                                               mul(alpha, dst.read_unaligned()),
          .                                               mul(beta, *accum.offset(M_ITER + $mr_div_n * N_ITER)),
          .                                               ));
          .                                   }});
-- line 349 ----------------------------------------
-- line 363 ----------------------------------------
          .                               seq_macro::seq!(N_ITER in 0..$nr {{
          .                                   seq_macro::seq!(M_ITER in 0..$mr_div_n {{
          .                                       let dst = dst.offset(M_ITER * N as isize + N_ITER * dst_cs) as *mut Pack;
          .                                       dst.write_unaligned(mul(beta, *accum.offset(M_ITER + $mr_div_n * N_ITER)));
          .                                   }});
          .                               }});
          .                           }
          .                       } else {
          0                           let src = accum_storage; // write to stack
          .                           let src = src.as_ptr() as *const T;
          .           
          0                           if alpha_status == 2 {
          .                               for j in 0..n {
          .                                   let dst_j = dst.offset(dst_cs * j as isize);
          .                                   let src_j = src.add(j * $mr_div_n * N);
          .           
          .                                   for i in 0..m {
          .                                       let dst_ij = dst_j.offset(dst_rs * i as isize);
          .                                       let src_ij = src_j.add(i);
          .           
-- line 382 ----------------------------------------
-- line 384 ----------------------------------------
          .                                   }
          .                               }
          .                           } else if alpha_status == 1 {
          .                               for j in 0..n {
          .                                   let dst_j = dst.offset(dst_cs * j as isize);
          .                                   let src_j = src.add(j * $mr_div_n * N);
          .           
          .                                   for i in 0..m {
          0                                       let dst_ij = dst_j.offset(dst_rs * i as isize);
          .                                       let src_ij = src_j.add(i);
          .           
    943,516   (0.9%)                              *dst_ij = *dst_ij + beta * *src_ij;
          .                                   }
          .                               }
          .                           } else {
          .                               for j in 0..n {
          .                                   let dst_j = dst.offset(dst_cs * j as isize);
          .                                   let src_j = src.add(j * $mr_div_n * N);
          .           
          .                                   for i in 0..m {
          .                                       let dst_ij = dst_j.offset(dst_rs * i as isize);
          .                                       let src_ij = src_j.add(i);
          .           
          0                                       *dst_ij = beta * *src_ij;
          .                                   }
          .                               }
          .                           }
          .                       }
          .           
      4,050   (0.0%)          }
          .               };
          .           }
          .           
          .           #[macro_export]
          .           macro_rules! microkernel_cplx {
          .               ($([$target: tt])?, $unroll: tt, $name: ident, $mr_div_n: tt, $nr: tt) => {
          .                   #[inline]
          .                   $(#[target_feature(enable = $target)])?
-- line 421 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gemm-common-0.15.4/src/pack_operands.rs
--------------------------------------------------------------------------------
Ir____________ 

215,836 (0.2%)  <unknown (line 0)>

      .         use crate::simd::Simd;
      .         
      .         #[inline(always)]
      .         pub fn quick_zero<T: Copy>(slice: &mut [T]) {
      .             let n = slice.len();
      .             match n {
      0                 1 => unsafe { *(slice.as_mut_ptr() as *mut [T; 1]) = core::mem::zeroed() },
      .                 2 => unsafe { *(slice.as_mut_ptr() as *mut [T; 2]) = core::mem::zeroed() },
      .                 3 => unsafe { *(slice.as_mut_ptr() as *mut [T; 3]) = core::mem::zeroed() },
      .                 4 => unsafe { *(slice.as_mut_ptr() as *mut [T; 4]) = core::mem::zeroed() },
      .                 5 => unsafe { *(slice.as_mut_ptr() as *mut [T; 5]) = core::mem::zeroed() },
      .                 6 => unsafe { *(slice.as_mut_ptr() as *mut [T; 6]) = core::mem::zeroed() },
      .                 7 => unsafe { *(slice.as_mut_ptr() as *mut [T; 7]) = core::mem::zeroed() },
      .                 8 => unsafe { *(slice.as_mut_ptr() as *mut [T; 8]) = core::mem::zeroed() },
      0                 9 => unsafe { *(slice.as_mut_ptr() as *mut [T; 9]) = core::mem::zeroed() },
      0                 10 => unsafe { *(slice.as_mut_ptr() as *mut [T; 10]) = core::mem::zeroed() },
      0                 11 => unsafe { *(slice.as_mut_ptr() as *mut [T; 11]) = core::mem::zeroed() },
      .                 12 => unsafe { *(slice.as_mut_ptr() as *mut [T; 12]) = core::mem::zeroed() },
      .                 13 => unsafe { *(slice.as_mut_ptr() as *mut [T; 13]) = core::mem::zeroed() },
      .                 14 => unsafe { *(slice.as_mut_ptr() as *mut [T; 14]) = core::mem::zeroed() },
      .                 15 => unsafe { *(slice.as_mut_ptr() as *mut [T; 15]) = core::mem::zeroed() },
      .                 16 => unsafe { *(slice.as_mut_ptr() as *mut [T; 16]) = core::mem::zeroed() },
      .                 17 => unsafe { *(slice.as_mut_ptr() as *mut [T; 17]) = core::mem::zeroed() },
      .                 18 => unsafe { *(slice.as_mut_ptr() as *mut [T; 18]) = core::mem::zeroed() },
      .                 19 => unsafe { *(slice.as_mut_ptr() as *mut [T; 19]) = core::mem::zeroed() },
-- line 25 ----------------------------------------
-- line 73 ----------------------------------------
      .                         *value = unsafe { core::mem::zeroed() };
      .                     }
      .                 }
      .             }
      .         }
      .         
      .         #[inline(always)]
      .         unsafe fn quick_copy<T: Copy>(dst: *mut T, src: *const T, n: usize) {
      0             match n {
      0                 1 => unsafe { *(dst as *mut [T; 1]) = *(src as *const [T; 1]) },
      0                 2 => unsafe { *(dst as *mut [T; 2]) = *(src as *const [T; 2]) },
      0                 3 => unsafe { *(dst as *mut [T; 3]) = *(src as *const [T; 3]) },
      .                 4 => unsafe { *(dst as *mut [T; 4]) = *(src as *const [T; 4]) },
      .                 5 => unsafe { *(dst as *mut [T; 5]) = *(src as *const [T; 5]) },
      .                 6 => unsafe { *(dst as *mut [T; 6]) = *(src as *const [T; 6]) },
      .                 7 => unsafe { *(dst as *mut [T; 7]) = *(src as *const [T; 7]) },
      .                 8 => unsafe { *(dst as *mut [T; 8]) = *(src as *const [T; 8]) },
      .                 9 => unsafe { *(dst as *mut [T; 9]) = *(src as *const [T; 9]) },
      .                 10 => unsafe { *(dst as *mut [T; 10]) = *(src as *const [T; 10]) },
      .                 11 => unsafe { *(dst as *mut [T; 11]) = *(src as *const [T; 11]) },
-- line 92 ----------------------------------------
-- line 151 ----------------------------------------
      .         unsafe fn pack_generic_inner_loop<T: Copy, const N: usize, const DST_WIDTH: usize>(
      .             mut dst: *mut T,
      .             mut src: *const T,
      .             src_rs: isize,
      .             src_cs: isize,
      .             src_width: usize,
      .             k: usize,
      .         ) {
      0             if src_width == DST_WIDTH {
      0                 if src_rs == 1 {
      .                     for _ in 0..k {
      .                         let val = (src as *const [T; DST_WIDTH]).read();
      .                         (dst as *mut [T; DST_WIDTH]).write(val);
      .         
      .                         src = src.wrapping_offset(src_cs);
      .                         dst = dst.add(DST_WIDTH);
      .                     }
      .                 } else {
-- line 168 ----------------------------------------
-- line 170 ----------------------------------------
      .                         for j in 0..DST_WIDTH {
      .                             *dst.add(j) = *src.offset(j as isize * src_rs);
      .                         }
      .                         src = src.wrapping_offset(src_cs);
      .                         dst = dst.add(DST_WIDTH);
      .                     }
      .                 }
      .             } else if src_width == N {
      0                 if src_rs == 1 {
      .                     for _ in 0..k {
      .                         let val = (src as *const [T; N]).read();
      .                         (dst as *mut [T; N]).write(val);
      .         
      .                         src = src.wrapping_offset(src_cs);
      .                         dst = dst.add(DST_WIDTH);
      .                     }
      .                 } else {
-- line 186 ----------------------------------------
-- line 188 ----------------------------------------
      .                         for j in 0..N {
      .                             *dst.add(j) = *src.offset(j as isize * src_rs);
      .                         }
      .                         src = src.wrapping_offset(src_cs);
      .                         dst = dst.add(DST_WIDTH);
      .                     }
      .                 }
      .             } else if src_width == 2 * N {
      0                 if src_rs == 1 {
      .                     for _ in 0..k {
      .                         let val0 = (src as *const [T; N]).read();
      .                         let val1 = (src.add(N) as *const [T; N]).read();
      .                         (dst as *mut [T; N]).write(val0);
      .                         (dst.add(N) as *mut [T; N]).write(val1);
      .         
      .                         src = src.wrapping_offset(src_cs);
      .                         dst = dst.add(DST_WIDTH);
-- line 204 ----------------------------------------
-- line 208 ----------------------------------------
      .                         for j in 0..2 * N {
      .                             *dst.add(j) = *src.offset(j as isize * src_rs);
      .                         }
      .                         src = src.wrapping_offset(src_cs);
      .                         dst = dst.add(DST_WIDTH);
      .                     }
      .                 }
      .             } else {
      0                 if src_rs == 1 {
      .                     for _ in 0..k {
      .                         quick_copy(dst, src, src_width);
      .                         quick_zero(core::slice::from_raw_parts_mut(
      .                             dst.add(src_width),
      .                             DST_WIDTH - src_width,
      .                         ));
      .                         src = src.wrapping_offset(src_cs);
      .                         dst = dst.add(DST_WIDTH);
-- line 224 ----------------------------------------
-- line 244 ----------------------------------------
      .             m: usize,
      .             k: usize,
      .             mut dst: *mut T,
      .             mut src: *const T,
      .             src_cs: isize,
      .             src_rs: isize,
      .             dst_stride: usize,
      .         ) {
      0             let m_width = m / DST_WIDTH * DST_WIDTH;
      .         
      .             let mut i = 0;
437,500 (0.4%)      while i < m_width {
      .                 pack_generic_inner_loop::<_, N, DST_WIDTH>(dst, src, src_rs, src_cs, DST_WIDTH, k);
      .                 src = src.wrapping_offset(src_rs * DST_WIDTH as isize);
      .                 dst = dst.add(dst_stride);
      .         
      0                 i += DST_WIDTH;
      .             }
104,736 (0.1%)      if i < m {
      .                 pack_generic_inner_loop::<_, N, DST_WIDTH>(dst, src, src_rs, src_cs, m - i, k);
      .             }
      .         }
      .         
      .         #[inline(never)]
      0         pub unsafe fn pack_lhs<T: Copy, const N: usize, const MR: usize, S: Simd>(
      .             _: S,
      .             m: usize,
      .             k: usize,
      .             dst: crate::Ptr<T>,
      .             src: crate::Ptr<T>,
      .             src_cs: isize,
      .             src_rs: isize,
      .             dst_stride: usize,
      .         ) {
      0             let dst = dst.0;
      0             let src = src.0;
      0             S::vectorize(
      .                 #[inline(always)]
      0                 || pack_generic::<T, N, MR>(m, k, dst, src, src_cs, src_rs, dst_stride),
      .             );
      0         }
      .         
      .         #[inline(never)]
      0         pub unsafe fn pack_rhs<T: Copy, const N: usize, const NR: usize, S: Simd>(
      .             _: S,
      .             n: usize,
      .             k: usize,
      .             dst: crate::Ptr<T>,
      .             src: crate::Ptr<T>,
      .             src_cs: isize,
      .             src_rs: isize,
      .             dst_stride: usize,
      .         ) {
      0             let dst = dst.0;
      0             let src = src.0;
      0             S::vectorize(
      .                 #[inline(always)]
      0                 || pack_generic::<T, N, NR>(n, k, dst, src, src_rs, src_cs, dst_stride),
      .             );
      0         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.3/src/base/iter.rs
--------------------------------------------------------------------------------
Ir__________________ 

          1   (0.0%)  <unknown (line 0)>

-- line 30 ----------------------------------------
          .                   // TODO: we need to specialize for the case where the matrix storage is owned (in which
          .                   // case the iterator is trivial because it does not have any stride).
          .                   impl<'a, T, R: Dim, C: Dim, S: 'a + $Storage<T, R, C>> $Name<'a, T, R, C, S> {
          .                       /// Creates a new iterator for the given matrix storage.
          .                       pub fn new(storage: $SRef) -> $Name<'a, T, R, C, S> {
          .                           let shape = storage.shape();
          .                           let strides = storage.strides();
          .                           let inner_offset = shape.0.value() * strides.0.value();
          0                           let size = shape.0.value() * shape.1.value();
          .                           let ptr = storage.$ptr();
          .           
          .                           // If we have a size of 0, 'ptr' must be
          .                           // dangling. However, 'inner_offset' might
          .                           // not be zero if only one dimension is zero, so
          .                           // we don't want to call 'offset'.
          .                           // This pointer will never actually get used
          .                           // if our size is '0', so it's fine to use
          .                           // 'ptr' for both the start and end.
         -1  (-0.0%)                  let inner_end = if size == 0 {
          .                               ptr
          .                           } else {
          .                               // Safety:
          .                               // If 'size' is non-zero, we know that 'ptr'
          .                               // is not dangling, and 'inner_offset' must lie
          .                               // within the allocation
          .                               unsafe { ptr.add(inner_offset) }
          .                           };
-- line 56 ----------------------------------------
-- line 67 ----------------------------------------
          .                   }
          .           
          .                   impl<'a, T, R: Dim, C: Dim, S: 'a + $Storage<T, R, C>> Iterator for $Name<'a, T, R, C, S> {
          .                       type Item = $Ref;
          .           
          .                       #[inline]
          .                       fn next(&mut self) -> Option<$Ref> {
          .                           unsafe {
          0                               if self.size == 0 {
          .                                   None
          .                               } else {
          0                                   self.size -= 1;
          .           
          .                                   // Jump to the next outer dimension if needed.
 86,093,441  (79.3%)                          if self.ptr == self.inner_end {
          .                                       let stride = self.strides.1.value() as isize;
          .                                       // This might go past the end of the allocation,
          .                                       // depending on the value of 'size'. We use
          .                                       // `wrapping_offset` to avoid UB
          .                                       self.inner_end = self.ptr.wrapping_offset(stride);
          .                                       // This will always be in bounds, since
          .                                       // we're going to dereference it
          .                                       self.ptr = self.inner_ptr.offset(stride);
-- line 89 ----------------------------------------
-- line 92 ----------------------------------------
          .           
          .                                   // Go to the next element.
          .                                   let old = self.ptr;
          .           
          .                                   // Don't offset `self.ptr` for the last element,
          .                                   // as this will be out of bounds. Iteration is done
          .                                   // at this point (the next call to `next` will return `None`)
          .                                   // so this is not observable.
-43,046,719 (-39.6%)                          if self.size != 0 {
          .                                       let stride = self.strides.0.value();
          .                                       self.ptr = self.ptr.add(stride);
          .                                   }
          .           
          .                                   // We want either `& *last` or `&mut *last` here, depending
          .                                   // on the mutability of `$Ref`.
          .                                   #[allow(clippy::transmute_ptr_to_ref)]
          .                                   Some(mem::transmute(old))
-- line 108 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/core_arch/mod.rs
--------------------------------------------------------------------------------
Ir_______________ 

-- line 261 ----------------------------------------
        .                              } else {
        .                                  None
        .                              }
        .                          }
        .          
        .                          /// Returns `true` if the required CPU features for this type are available,
        .                          /// otherwise returns `false`.
        .                          #[inline]
 -135,475 (-0.1%)                  pub fn is_available() -> bool {
1,625,700  (1.5%)                      true $(&& <__impl_type!($feature)>::is_available())*
 -270,950 (-0.2%)                  }
        .          
        .                          /// Vectorizes the given function as if the CPU features for this type were applied
        .                          /// to it.
        .                          ///
        .                          /// # Note
        .                          /// For the vectorization to work properly, the given function must be inlined.
        .                          /// Consider marking it as `#[inline(always)]`
        .                          #[inline(always)]
        .                          pub fn vectorize<F: $crate::NullaryFnOnce>(self, f: F) -> F::Output {
        .                              $(#[target_feature(enable = $feature)])*
        .                              #[inline]
  -37,632 (-0.0%)                      unsafe fn __impl<F: $crate::NullaryFnOnce>(f: F) -> F::Output {
        .                                  f.call()
  -37,632 (-0.0%)                      }
        .                              unsafe { __impl(f) }
        .                          }
        .          
        .                          /// Takes a proof of the existence of this SIMD token (`self`), and returns a
        .                          /// persistent reference to it.
        .                          #[inline]
        .                          pub fn to_ref(self) -> &'static Self {
        .                              const __ASSERT_ZST: () = {
-- line 293 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/lib.rs
--------------------------------------------------------------------------------
Ir____________ 

100,099 (0.1%)  <unknown (line 0)>

-- line 1213 ----------------------------------------
      .             assert_eq!(core::mem::size_of::<U>() % core::mem::size_of::<T>(), 0);
      .             assert_eq!(core::mem::align_of::<U>(), core::mem::align_of::<T>());
      .         
      .             let chunk_size = core::mem::size_of::<U>() / core::mem::size_of::<T>();
      .         
      .             let len = slice.len();
      .             let data = slice.as_ptr();
      .         
      0             let div = len / chunk_size;
      0             let rem = len % chunk_size;
      .             (
      .                 from_raw_parts(data as *const U, div),
      .                 from_raw_parts(data.add(len - rem), rem),
      .             )
      .         }
      .         
      .         #[inline(always)]
      .         unsafe fn split_mut_slice<T, U>(slice: &mut [T]) -> (&mut [U], &mut [T]) {
-- line 1230 ----------------------------------------
-- line 1268 ----------------------------------------
      .         
      .         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
      .         use x86::ArchInner;
      .         
      .         impl Arch {
      .             #[inline]
      .             pub fn new() -> Self {
      .                 Self {
135,475 (0.1%)              inner: ArchInner::new(),
      .                 }
      .             }
      .             #[inline(always)]
      .             pub fn dispatch<Op: WithSimd>(self, op: Op) -> Op::Output {
      .                 self.inner.dispatch(op)
      .             }
      .         }
      .         
-- line 1284 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulp-0.13.2/src/x86.rs
--------------------------------------------------------------------------------
Ir________________ 

    60,087  (0.1%)  <unknown (line 0)>

-- line 1148 ----------------------------------------
         .              pub m32,
         .          );
         .          
         .          /// A 128-bit SIMD vector with 2 elements of type [`f64`].
         .          #[derive(Debug, Copy, Clone, PartialEq)]
         .          #[repr(C)]
         .          pub struct f64x2(pub f64, pub f64);
         .          /// A 256-bit SIMD vector with 4 elements of type [`f64`].
         0          #[derive(Debug, Copy, Clone, PartialEq)]
         .          #[repr(C)]
         .          pub struct f64x4(pub f64, pub f64, pub f64, pub f64);
         .          /// A 512-bit SIMD vector with 8 elements of type [`f64`].
         .          #[derive(Debug, Copy, Clone, PartialEq)]
         .          #[repr(C)]
         .          pub struct f64x8(
         .              pub f64,
         .              pub f64,
-- line 1164 ----------------------------------------
-- line 1470 ----------------------------------------
         .          impl f64x8 {
         .              #[inline]
         .              fn as_vec(self) -> __m512d {
         .                  unsafe { transmute(self) }
         .              }
         .          }
         .          
         .          // https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels
   -38,557 (-0.0%)  internal_simd_type! {
         .              /// SSE instruction set.
         .              #[allow(missing_docs)]
         .              pub struct V2 {
         .                  pub sse: "sse",
         .                  pub sse2: "sse2",
         .                  pub fxsr: "fxsr",
         .                  pub sse3: "sse3",
         .                  pub ssse3: "ssse3",
-- line 1486 ----------------------------------------
-- line 1994 ----------------------------------------
         .                      this: V3,
         .                      op: Op,
         .                  }
         .                  impl<Op: WithSimd> crate::NullaryFnOnce for Impl<Op> {
         .                      type Output = Op::Output;
         .          
         .                      #[inline(always)]
         .                      fn call(self) -> Self::Output {
         0                          self.op.with_simd(self.this)
         .                      }
         .                  }
-1,064,097 (-1.0%)          self.vectorize(Impl { this: self, op })
         .              }
         .          
         .              #[inline(always)]
         .              fn f32s_reduce_sum(self, a: Self::f32s) -> f32 {
         .                  unsafe {
         .                      let a: __m256 = transmute(a);
         .                      let r = _mm_add_ps(_mm256_castps256_ps128(a), _mm256_extractf128_ps::<1>(a));
         .                      (*self).f32s_reduce_sum(transmute(r))
-- line 2013 ----------------------------------------
-- line 9767 ----------------------------------------
         .              V4(V4),
         .              V3(V3),
         .              Scalar(crate::Scalar),
         .          }
         .          
         .          impl ArchInner {
         .              /// Detects the best available instruction set.
         .              #[inline]
   135,475  (0.1%)      pub fn new() -> Self {
         .                  #[cfg(feature = "nightly")]
         .                  if let Some(simd) = V4::try_new() {
         .                      return Self::V4(simd);
         .                  }
   135,475  (0.1%)          if let Some(simd) = V3::try_new() {
         .                      return Self::V3(simd);
         .                  }
         .                  Self::Scalar(crate::Scalar::new())
   406,425  (0.4%)      }
         .          
         .              /// Detects the best available instruction set.
         .              #[inline(always)]
         .              pub fn dispatch<Op: WithSimd>(self, op: Op) -> Op::Output {
   549,133  (0.5%)          match self {
         .                      #[cfg(feature = "nightly")]
         .                      ArchInner::V4(simd) => Simd::vectorize(simd, op),
         .                      ArchInner::V3(simd) => Simd::vectorize(simd, op),
         .                      ArchInner::Scalar(simd) => Simd::vectorize(simd, op),
         .                  }
         .              }
         .          }
         .          
-- line 9797 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/job.rs
--------------------------------------------------------------------------------
Ir_____________ 

  5,598  (0.0%)  <unknown (line 0)>

-- line 56 ----------------------------------------
      .              /// without making `JobRef` itself `Copy + Eq`.
      .              #[inline]
      .              pub(super) fn id(&self) -> impl Eq {
      .                  (self.pointer, self.execute_fn)
      .              }
      .          
      .              #[inline]
      .              pub(super) unsafe fn execute(self) {
 -3,636 (-0.0%)          (self.execute_fn)(self.pointer)
      .              }
      .          }
      .          
      .          /// A job that will be owned by a stack slot. This means that when it
      .          /// executes it need not free any heap data, the cleanup occurs when
      .          /// the stack frame is later popped.  The function parameter indicates
      .          /// `true` if the job was stolen -- executed on a different thread.
      .          pub(super) struct StackJob<L, F, R>
-- line 72 ----------------------------------------
-- line 82 ----------------------------------------
      .          
      .          impl<L, F, R> StackJob<L, F, R>
      .          where
      .              L: Latch + Sync,
      .              F: FnOnce(bool) -> R + Send,
      .              R: Send,
      .          {
      .              pub(super) fn new(func: F, latch: L) -> StackJob<L, F, R> {
189,696  (0.2%)          StackJob {
      .                      latch,
      .                      func: UnsafeCell::new(Some(func)),
      .                      result: UnsafeCell::new(JobResult::None),
      .                  }
      .              }
      .          
      .              pub(super) unsafe fn as_job_ref(&self) -> JobRef {
      .                  JobRef::new(self)
      .              }
      .          
      .              pub(super) unsafe fn run_inline(self, stolen: bool) -> R {
   -279 (-0.0%)          self.func.into_inner().unwrap()(stolen)
      .              }
      .          
      .              pub(super) unsafe fn into_result(self) -> R {
      .                  self.result.into_inner().into_return_value()
      .              }
      .          }
      .          
      .          impl<L, F, R> Job for StackJob<L, F, R>
      .          where
      .              L: Latch + Sync,
      .              F: FnOnce(bool) -> R + Send,
      .              R: Send,
      .          {
  1,043  (0.0%)      unsafe fn execute(this: *const ()) {
      .                  let this = &*(this as *const Self);
      .                  let abort = unwind::AbortIfPanic;
      .                  let func = (*this.func.get()).take().unwrap();
    417  (0.0%)          (*this.result.get()) = JobResult::call(func);
      0                  Latch::set(&this.latch);
      .                  mem::forget(abort);
  1,016  (0.0%)      }
      .          }
      .          
      .          /// Represents a job stored in the heap. Used to implement
      .          /// `scope`. Unlike `StackJob`, when executed, `HeapJob` simply
      .          /// invokes a closure, which then triggers the appropriate logic to
      .          /// signal that the job executed.
      .          ///
      .          /// (Probably `StackJob` should be refactored in a similar fashion.)
-- line 131 ----------------------------------------
-- line 221 ----------------------------------------
      .                  }
      .              }
      .          
      .              /// Convert the `JobResult` for a job that has finished (and hence
      .              /// its JobResult is populated) into its return value.
      .              ///
      .              /// NB. This will panic if the job panicked.
      .              pub(super) fn into_return_value(self) -> T {
    278  (0.0%)          match self {
      .                      JobResult::None => unreachable!(),
      .                      JobResult::Ok(x) => x,
      .                      JobResult::Panic(x) => unwind::resume_unwinding(x),
      .                  }
      .              }
      .          }
      .          
      .          /// Indirect queue to provide FIFO job priority.
-- line 237 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/join/mod.rs
--------------------------------------------------------------------------------
Ir______________ 

     -64 (-0.0%)  <unknown (line 0)>

-- line 94 ----------------------------------------
       .          where
       .              A: FnOnce() -> RA + Send,
       .              B: FnOnce() -> RB + Send,
       .              RA: Send,
       .              RB: Send,
       .          {
       .              #[inline]
       .              fn call<R>(f: impl FnOnce() -> R) -> impl FnOnce(FnContext) -> R {
  19,464  (0.0%)          move |_| f()
       .              }
       .          
  14,598  (0.0%)      join_context(call(oper_a), call(oper_b))
       .          }
       .          
       .          /// Identical to `join`, except that the closures have a parameter
       .          /// that provides context for the way the closure has been called,
       .          /// especially indicating whether they're executing on a different
       .          /// thread than where `join_context` was called.  This will occur if
       .          /// the second job is stolen by a different thread, or if
       .          /// `join_context` was called from outside the thread pool to begin
-- line 113 ----------------------------------------
-- line 124 ----------------------------------------
       .                  move || f(FnContext::new(injected))
       .              }
       .          
       .              #[inline]
       .              fn call_b<R>(f: impl FnOnce(FnContext) -> R) -> impl FnOnce(bool) -> R {
       .                  move |migrated| f(FnContext::new(migrated))
       .              }
       .          
 422,404  (0.4%)      registry::in_worker(|worker_thread, injected| unsafe {
       .                  // Create virtual wrapper for task b; this all has to be
       .                  // done here so that the stack frame can keep it all live
       .                  // long enough.
-189,696 (-0.2%)          let job_b = StackJob::new(call_b(oper_b), SpinLatch::new(worker_thread));
       .                  let job_b_ref = job_b.as_job_ref();
       .                  let job_b_id = job_b_ref.id();
       .                  worker_thread.push(job_b_ref);
       .          
       .                  // Execute task a; hopefully b gets stolen in the meantime.
       0                  let status_a = unwind::halt_unwinding(call_a(oper_a, injected));
       .                  let result_a = match status_a {
       .                      Ok(v) => v,
       .                      Err(err) => join_recover_from_panic(worker_thread, &job_b.latch, err),
       .                  };
       .          
       .                  // Now that task A has finished, try to pop job B from the
       .                  // local stack.  It may already have been popped by job A; it
       .                  // may also have been stolen. There may also be some tasks
       .                  // pushed on top of it in the stack, and we will have to pop
       .                  // those off to get to it.
       0                  while !job_b.latch.probe() {
       .                      if let Some(job) = worker_thread.take_local_job() {
       .                          if job_b_id == job.id() {
       .                              // Found it! Let's run it.
       .                              //
       .                              // Note that this could panic, but it's ok if we unwind here.
  -1,666 (-0.0%)                      let result_b = job_b.run_inline(injected);
       .                              return (result_a, result_b);
       .                          } else {
       .                              worker_thread.execute(job);
       .                          }
       .                      } else {
       .                          // Local deque is empty. Time to steal from other
       .                          // threads.
       .                          worker_thread.wait_until(&job_b.latch);
       .                          debug_assert!(job_b.latch.probe());
       .                          break;
       .                      }
       .                  }
       .          
     139  (0.0%)          (result_a, job_b.into_result())
       0              })
       .          }
       .          
       .          /// If job A panics, we still cannot return until we are sure that job
       .          /// B is complete. This is because it may contain references into the
       .          /// enclosing stack frame(s).
       .          #[cold] // cold path
       .          unsafe fn join_recover_from_panic(
       .              worker_thread: &WorkerThread,
-- line 182 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/latch.rs
--------------------------------------------------------------------------------
Ir______________ 

  23,130  (0.0%)  <unknown (line 0)>

-- line 104 ----------------------------------------
       .                      .is_ok()
       .              }
       .          
       .              /// Invoked by owning thread as it falls asleep sleep. Returns
       .              /// true if the owning thread should block, or false if the latch
       .              /// was set in the meantime.
       .              #[inline]
       .              pub(super) fn wake_up(&self) {
  16,710  (0.0%)          if !self.probe() {
       .                      let _ =
       .                          self.state
       .                              .compare_exchange(SLEEPING, UNSET, Ordering::SeqCst, Ordering::Relaxed);
       .                  }
       .              }
       .          
       .              /// Set the latch. If this returns true, the owning thread was sleeping
       .              /// and must be awoken.
       .              ///
       .              /// This is private because, typically, setting a latch involves
       .              /// doing some wakeups; those are encapsulated in the surrounding
       .              /// latch code.
       .              #[inline]
       .              unsafe fn set(this: *const Self) -> bool {
       .                  let old_state = (*this).state.swap(SET, Ordering::AcqRel);
     139  (0.0%)          old_state == SLEEPING
       .              }
       .          
       .              /// Test if this latch has been set.
       .              #[inline]
       .              pub(super) fn probe(&self) -> bool {
-530,524 (-0.5%)          self.state.load(Ordering::Acquire) == SET
       .              }
       .          }
       .          
       .          impl AsCoreLatch for CoreLatch {
       .              #[inline]
       .              fn as_core_latch(&self) -> &CoreLatch {
       .                  self
       .              }
-- line 142 ----------------------------------------
-- line 156 ----------------------------------------
       .              /// Creates a new spin latch that is owned by `thread`. This means
       .              /// that `thread` is the only thread that should be blocking on
       .              /// this latch -- it also means that when the latch is set, we
       .              /// will wake `thread` if it is sleeping.
       .              #[inline]
       .              pub(super) fn new(thread: &'r WorkerThread) -> SpinLatch<'r> {
       .                  SpinLatch {
       .                      core_latch: CoreLatch::new(),
  36,482  (0.0%)              registry: thread.registry(),
       .                      target_worker_index: thread.index(),
       .                      cross: false,
       .                  }
       .              }
       .          
       .              /// Creates a new spin latch for cross-threadpool blocking.  Notably, we
       .              /// need to make sure the registry is kept alive after setting, so we can
       .              /// safely call the notification.
-- line 172 ----------------------------------------
-- line 191 ----------------------------------------
       .              }
       .          }
       .          
       .          impl<'r> Latch for SpinLatch<'r> {
       .              #[inline]
       .              unsafe fn set(this: *const Self) {
       .                  let cross_registry;
       .          
     556  (0.0%)          let registry: &Registry = if (*this).cross {
       .                      // Ensure the registry stays alive while we notify it.
       .                      // Otherwise, it would be possible that we set the spin
       .                      // latch and the other thread sees it and exits, causing
       .                      // the registry to be deallocated, all before we get a
       .                      // chance to invoke `registry.notify_worker_latch_is_set`.
       .                      cross_registry = Arc::clone((*this).registry);
       .                      &cross_registry
       .                  } else {
       .                      // If this is not a "cross-registry" spin-latch, then the
       .                      // thread which is performing `set` is itself ensuring
       .                      // that the registry stays alive. However, that doesn't
       .                      // include this *particular* `Arc` handle if the waiting
       .                      // thread then exits, so we must completely dereference it.
       .                      (*this).registry
       .                  };
     139  (0.0%)          let target_worker_index = (*this).target_worker_index;
       .          
       .                  // NOTE: Once we `set`, the target may proceed and invalidate `this`!
     139  (0.0%)          if CoreLatch::set(&(*this).core_latch) {
       .                      // Subtle: at this point, we can no longer read from
       .                      // `self`, because the thread owning this spin latch may
       .                      // have awoken and deallocated the latch. Therefore, we
       .                      // only use fields whose values we already read.
       .                      registry.notify_worker_latch_is_set(target_worker_index);
       .                  }
     139  (0.0%)      }
       .          }
       .          
       .          /// A Latch starts as false and eventually becomes true. You can block
       .          /// until it becomes true.
       .          #[derive(Debug)]
       .          pub(super) struct LockLatch {
       .              m: Mutex<bool>,
       .              v: Condvar,
-- line 233 ----------------------------------------
-- line 238 ----------------------------------------
       .              pub(super) fn new() -> LockLatch {
       .                  LockLatch {
       .                      m: Mutex::new(false),
       .                      v: Condvar::new(),
       .                  }
       .              }
       .          
       .              /// Block until latch is set, then resets this lock latch so it can be reused again.
       0              pub(super) fn wait_and_reset(&self) {
       .                  let mut guard = self.m.lock().unwrap();
       0                  while !*guard {
       0                      guard = self.v.wait(guard).unwrap();
       .                  }
       0                  *guard = false;
     -96 (-0.0%)      }
       .          
       .              /// Block until latch is set.
       .              pub(super) fn wait(&self) {
       .                  let mut guard = self.m.lock().unwrap();
       .                  while !*guard {
       .                      guard = self.v.wait(guard).unwrap();
       .                  }
       .              }
       .          }
       .          
       .          impl Latch for LockLatch {
       .              #[inline]
       0              unsafe fn set(this: *const Self) {
       .                  let mut guard = (*this).m.lock().unwrap();
       0                  *guard = true;
       0                  (*this).v.notify_all();
       0              }
       .          }
       .          
       .          /// Once latches are used to implement one-time blocking, primarily
       .          /// for the termination flag of the threads in the pool.
       .          ///
       .          /// Note: like a `SpinLatch`, once-latches are always associated with
       .          /// some registry that is probing them, which must be tickled when
       .          /// they are set. *Unlike* a `SpinLatch`, they don't themselves hold a
-- line 277 ----------------------------------------
-- line 443 ----------------------------------------
       .          
       .          unsafe impl<L: Sync> Sync for LatchRef<'_, L> {}
       .          
       .          impl<L> Deref for LatchRef<'_, L> {
       .              type Target = L;
       .          
       .              fn deref(&self) -> &L {
       .                  // SAFETY: if we have &self, the inner latch is still alive
       0                  unsafe { &*self.inner }
       .              }
       .          }
       .          
       .          impl<L: Latch> Latch for LatchRef<'_, L> {
       .              #[inline]
       .              unsafe fn set(this: *const Self) {
       .                  L::set((*this).inner);
       .              }
-- line 459 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/registry.rs
--------------------------------------------------------------------------------
Ir________________ 

-9,247,347 (-8.5%)  <unknown (line 0)>

-- line 83 ----------------------------------------
         .          #[derive(Debug, Default)]
         .          pub struct DefaultSpawn;
         .          
         .          impl ThreadSpawn for DefaultSpawn {
         .              private_impl! {}
         .          
         .              fn spawn(&mut self, thread: ThreadBuilder) -> io::Result<()> {
         .                  let mut b = thread::Builder::new();
         0                  if let Some(name) = thread.name() {
         .                      b = b.name(name.to_owned());
         .                  }
       -80 (-0.0%)          if let Some(stack_size) = thread.stack_size() {
         .                      b = b.stack_size(stack_size);
         .                  }
      -600 (-0.0%)          b.spawn(|| thread.run())?;
         .                  Ok(())
         .              }
         .          }
         .          
         .          /// Spawns a thread with a user's custom callback.
         .          ///
         .          /// This type is pub-in-private -- E0445 forces us to make it public,
         .          /// but we don't actually want to expose these details in the API.
-- line 105 ----------------------------------------
-- line 156 ----------------------------------------
         .          /// Initialization
         .          
         .          static mut THE_REGISTRY: Option<Arc<Registry>> = None;
         .          static THE_REGISTRY_SET: Once = Once::new();
         .          
         .          /// Starts the worker threads (if that has not already happened). If
         .          /// initialization has not already occurred, use the default
         .          /// configuration.
         0          pub(super) fn global_registry() -> &'static Arc<Registry> {
         .              set_global_registry(default_global_registry)
         .                  .or_else(|err| unsafe { THE_REGISTRY.as_ref().ok_or(err) })
         .                  .expect("The global thread pool has not been initialized.")
         0          }
         .          
         .          /// Starts the worker threads (if that has not already happened) with
         .          /// the given builder.
         .          pub(super) fn init_global_registry<S>(
         .              builder: ThreadPoolBuilder<S>,
         .          ) -> Result<&'static Arc<Registry>, ThreadPoolBuildError>
         .          where
         .              S: ThreadSpawn,
-- line 176 ----------------------------------------
-- line 179 ----------------------------------------
         .          }
         .          
         .          /// Starts the worker threads (if that has not already happened)
         .          /// by creating a registry with the given callback.
         .          fn set_global_registry<F>(registry: F) -> Result<&'static Arc<Registry>, ThreadPoolBuildError>
         .          where
         .              F: FnOnce() -> Result<Arc<Registry>, ThreadPoolBuildError>,
         .          {
         0              let mut result = Err(ThreadPoolBuildError::new(
         .                  ErrorKind::GlobalPoolAlreadyInitialized,
         .              ));
         .          
         .              THE_REGISTRY_SET.call_once(|| {
         0                  result = registry()
         .                      .map(|registry: Arc<Registry>| unsafe { &*THE_REGISTRY.get_or_insert(registry) })
         .              });
         .          
         0              result
         .          }
         .          
         .          fn default_global_registry() -> Result<Arc<Registry>, ThreadPoolBuildError> {
         0              let result = Registry::new(ThreadPoolBuilder::new());
         .          
         .              // If we're running in an environment that doesn't support threads at all, we can fall back to
         .              // using the current thread alone. This is crude, and probably won't work for non-blocking
         .              // calls like `spawn` or `broadcast_spawn`, but a lot of stuff does work fine.
         .              //
         .              // Notably, this allows current WebAssembly targets to work even though their threading support
         .              // is stubbed out, and we won't have to change anything if they do add real threading.
         0              let unsupported = matches!(&result, Err(e) if e.is_unsupported());
         .              if unsupported && WorkerThread::current().is_null() {
         .                  let builder = ThreadPoolBuilder::new().num_threads(1).use_current_thread();
         .                  let fallback_result = Registry::new(builder);
         .                  if fallback_result.is_ok() {
         .                      return fallback_result;
         .                  }
         .              }
         .          
-- line 216 ----------------------------------------
-- line 221 ----------------------------------------
         .          
         .          impl<'a> Drop for Terminator<'a> {
         .              fn drop(&mut self) {
         .                  self.0.terminate()
         .              }
         .          }
         .          
         .          impl Registry {
         0              pub(super) fn new<S>(
         .                  mut builder: ThreadPoolBuilder<S>,
         .              ) -> Result<Arc<Self>, ThreadPoolBuildError>
         .              where
         .                  S: ThreadSpawn,
         .              {
         .                  // Soft-limit the number of threads that we can actually support.
         0                  let n_threads = Ord::min(builder.get_num_threads(), crate::max_num_threads());
         .          
         .                  let breadth_first = builder.get_breadth_first();
         .          
        -2 (-0.0%)          let (workers, stealers): (Vec<_>, Vec<_>) = (0..n_threads)
         .                      .map(|_| {
         0                          let worker = if breadth_first {
         .                              Worker::new_fifo()
         .                          } else {
         .                              Worker::new_lifo()
         .                          };
         .          
         .                          let stealer = worker.stealer();
         0                          (worker, stealer)
         .                      })
         .                      .unzip();
         .          
        -2 (-0.0%)          let (broadcasts, broadcast_stealers): (Vec<_>, Vec<_>) = (0..n_threads)
         .                      .map(|_| {
         0                          let worker = Worker::new_fifo();
         .                          let stealer = worker.stealer();
         0                          (worker, stealer)
         .                      })
         .                      .unzip();
         .          
         0                  let registry = Arc::new(Registry {
         3  (0.0%)              thread_infos: stealers.into_iter().map(ThreadInfo::new).collect(),
         .                      sleep: Sleep::new(n_threads),
         .                      injected_jobs: Injector::new(),
         .                      broadcasts: Mutex::new(broadcasts),
         .                      terminate_count: AtomicUsize::new(1),
         .                      panic_handler: builder.take_panic_handler(),
         .                      start_handler: builder.take_start_handler(),
         .                      exit_handler: builder.take_exit_handler(),
         .                  });
         .          
         .                  // If we return early or panic, make sure to terminate existing threads.
         .                  let t1000 = Terminator(&registry);
         .          
         0                  for (index, (worker, stealer)) in workers.into_iter().zip(broadcast_stealers).enumerate() {
        60  (0.0%)              let thread = ThreadBuilder {
         .                          name: builder.get_thread_name(index),
         .                          stack_size: builder.get_stack_size(),
        20  (0.0%)                  registry: Arc::clone(&registry),
         0                          worker,
         .                          stealer,
         .                          index,
         .                      };
         .          
         0                      if index == 0 && builder.use_current_thread {
         .                          if !WorkerThread::current().is_null() {
         .                              return Err(ThreadPoolBuildError::new(
         .                                  ErrorKind::CurrentThreadAlreadyInPool,
         .                              ));
         .                          }
         .                          // Rather than starting a new thread, we're just taking over the current thread
         .                          // *without* running the main loop, so we can still return from here.
         .                          // The WorkerThread is leaked, but we never shutdown the global pool anyway.
-- line 293 ----------------------------------------
-- line 295 ----------------------------------------
         .          
         .                          unsafe {
         .                              WorkerThread::set_current(worker_thread);
         .                              Latch::set(&registry.thread_infos[index].primed);
         .                          }
         .                          continue;
         .                      }
         .          
      -480 (-0.0%)              if let Err(e) = builder.get_spawn_handler().spawn(thread) {
         .                          return Err(ThreadPoolBuildError::new(ErrorKind::IOError(e)));
         .                      }
         .                  }
         .          
         .                  // Returning normally now, without termination.
         .                  mem::forget(t1000);
         .          
         0                  Ok(registry)
        -1 (-0.0%)      }
         .          
         .              pub(super) fn current() -> Arc<Registry> {
         .                  unsafe {
         .                      let worker_thread = WorkerThread::current();
         .                      let registry = if worker_thread.is_null() {
         .                          global_registry()
         .                      } else {
         .                          &(*worker_thread).registry
-- line 320 ----------------------------------------
-- line 324 ----------------------------------------
         .              }
         .          
         .              /// Returns the number of threads in the current registry.  This
         .              /// is better than `Registry::current().num_threads()` because it
         .              /// avoids incrementing the `Arc`.
         .              pub(super) fn current_num_threads() -> usize {
         .                  unsafe {
         .                      let worker_thread = WorkerThread::current();
       116  (0.0%)              if worker_thread.is_null() {
         0                          global_registry().num_threads()
         .                      } else {
        58  (0.0%)                  (*worker_thread).registry.num_threads()
         .                      }
         .                  }
         .              }
         .          
         .              /// Returns the current `WorkerThread` if it's part of this `Registry`.
         .              pub(super) fn current_thread(&self) -> Option<&WorkerThread> {
         .                  unsafe {
         .                      let worker = WorkerThread::current().as_ref()?;
-- line 343 ----------------------------------------
-- line 410 ----------------------------------------
         .                          self.inject(job_ref);
         .                      }
         .                  }
         .              }
         .          
         .              /// Push a job into the "external jobs" queue; it will be taken by
         .              /// whatever worker has nothing to do. Use this if you know that
         .              /// you are not on a worker of this registry.
         0              pub(super) fn inject(&self, injected_job: JobRef) {
         .                  // It should not be possible for `state.terminate` to be true
         .                  // here. It is only set to true when the user creates (and
         .                  // drops) a `ThreadPool`; and, in that case, they cannot be
         .                  // calling `inject()` later, since they dropped their
         .                  // `ThreadPool`.
         .                  debug_assert_ne!(
         .                      self.terminate_count.load(Ordering::Acquire),
         .                      0,
         .                      "inject() sees state.terminate as true"
         .                  );
         .          
         .                  let queue_was_empty = self.injected_jobs.is_empty();
         .          
         .                  self.injected_jobs.push(injected_job);
         .                  self.sleep.new_injected_jobs(1, queue_was_empty);
       -40 (-0.0%)      }
         .          
         .              fn has_injected_job(&self) -> bool {
         .                  !self.injected_jobs.is_empty()
         .              }
         .          
         .              fn pop_injected_job(&self) -> Option<JobRef> {
         .                  loop {
         .                      match self.injected_jobs.steal() {
-- line 442 ----------------------------------------
-- line 485 ----------------------------------------
         .              /// was performed, `false` if executed directly.
         .              pub(super) fn in_worker<OP, R>(&self, op: OP) -> R
         .              where
         .                  OP: FnOnce(&WorkerThread, bool) -> R + Send,
         .                  R: Send,
         .              {
         .                  unsafe {
         .                      let worker_thread = WorkerThread::current();
         0                      if worker_thread.is_null() {
    -5,071 (-0.0%)                  self.in_worker_cold(op)
         .                      } else if (*worker_thread).registry().id() != self.id() {
         .                          self.in_worker_cross(&*worker_thread, op)
         .                      } else {
         .                          // Perfectly valid to give them a `&T`: this is the
         .                          // current thread, so we know the data structure won't be
         .                          // invalidated until we return.
         .                          op(&*worker_thread, false)
         .                      }
         .                  }
         .              }
         .          
         .              #[cold]
       493  (0.0%)      unsafe fn in_worker_cold<OP, R>(&self, op: OP) -> R
         .              where
         .                  OP: FnOnce(&WorkerThread, bool) -> R + Send,
         .                  R: Send,
         .              {
         .                  thread_local!(static LOCK_LATCH: LockLatch = LockLatch::new());
         .          
         .                  LOCK_LATCH.with(|l| {
         .                      // This thread isn't a member of *any* thread pool, so just block.
         .                      debug_assert!(WorkerThread::current().is_null());
         .                      let job = StackJob::new(
         .                          |injected| {
         .                              let worker_thread = WorkerThread::current();
       493  (0.0%)                      assert!(injected && !worker_thread.is_null());
    -1,561 (-0.0%)                      op(&*worker_thread, true)
         .                          },
         .                          LatchRef::new(l),
         .                      );
         0                      self.inject(job.as_job_ref());
         0                      job.latch.wait_and_reset(); // Make sure we can use the same latch again next time.
         .          
         0                      job.into_result()
         .                  })
       493  (0.0%)      }
         .          
         .              #[cold]
         .              unsafe fn in_worker_cross<OP, R>(&self, current_thread: &WorkerThread, op: OP) -> R
         .              where
         .                  OP: FnOnce(&WorkerThread, bool) -> R + Send,
         .                  R: Send,
         .              {
         .                  // This thread is a member of a different pool, so let it process
-- line 538 ----------------------------------------
-- line 589 ----------------------------------------
         .                      for (i, thread_info) in self.thread_infos.iter().enumerate() {
         .                          unsafe { OnceLatch::set_and_tickle_one(&thread_info.terminate, self, i) };
         .                      }
         .                  }
         .              }
         .          
         .              /// Notify the worker that the latch they are sleeping on has been "set".
         .              pub(super) fn notify_worker_latch_is_set(&self, target_worker_index: usize) {
        54  (0.0%)          self.sleep.notify_worker_latch_is_set(target_worker_index);
         .              }
         .          }
         .          
         .          #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
         .          pub(super) struct RegistryId {
         .              addr: usize,
         .          }
         .          
-- line 605 ----------------------------------------
-- line 620 ----------------------------------------
         .              terminate: OnceLatch,
         .          
         .              /// the "stealer" half of the worker's deque
         .              stealer: Stealer<JobRef>,
         .          }
         .          
         .          impl ThreadInfo {
         .              fn new(stealer: Stealer<JobRef>) -> ThreadInfo {
         0                  ThreadInfo {
         .                      primed: LockLatch::new(),
         .                      stopped: LockLatch::new(),
         .                      terminate: OnceLatch::new(),
         .                      stealer,
         .                  }
         .              }
         .          }
         .          
-- line 636 ----------------------------------------
-- line 660 ----------------------------------------
         .          // thread local variable. So it will remain valid at least until the
         .          // worker is fully unwound. Using an unsafe pointer avoids the need
         .          // for a RefCell<T> etc.
         .          thread_local! {
         .              static WORKER_THREAD_STATE: Cell<*const WorkerThread> = const { Cell::new(ptr::null()) };
         .          }
         .          
         .          impl From<ThreadBuilder> for WorkerThread {
         0              fn from(thread: ThreadBuilder) -> Self {
         0                  Self {
         0                      worker: thread.worker,
         0                      stealer: thread.stealer,
         .                      fifo: JobFifo::new(),
         0                      index: thread.index,
         .                      rng: XorShift64Star::new(),
         0                      registry: thread.registry,
         .                  }
         0              }
         .          }
         .          
         .          impl Drop for WorkerThread {
         .              fn drop(&mut self) {
         .                  // Undo `set_current`
         .                  WORKER_THREAD_STATE.with(|t| {
         .                      assert!(t.get().eq(&(self as *const _)));
         .                      t.set(ptr::null());
-- line 685 ----------------------------------------
-- line 695 ----------------------------------------
         .              pub(super) fn current() -> *const WorkerThread {
         .                  WORKER_THREAD_STATE.with(Cell::get)
         .              }
         .          
         .              /// Sets `self` as the worker thread index for the current thread.
         .              /// This is done during worker thread startup.
         .              unsafe fn set_current(thread: *const WorkerThread) {
         .                  WORKER_THREAD_STATE.with(|t| {
        20  (0.0%)              assert!(t.get().is_null());
         .                      t.set(thread);
         .                  });
         .              }
         .          
         .              /// Returns the registry that owns this worker thread.
         .              #[inline]
         .              pub(super) fn registry(&self) -> &Arc<Registry> {
   -36,482 (-0.0%)          &self.registry
         .              }
         .          
         .              /// Our index amongst the worker threads (ranges from `0..self.num_threads()`).
         .              #[inline]
         .              pub(super) fn index(&self) -> usize {
         0                  self.index
         .              }
         .          
         .              #[inline]
         .              pub(super) unsafe fn push(&self, job: JobRef) {
         0                  let queue_was_empty = self.worker.is_empty();
         .                  self.worker.push(job);
         0                  self.registry.sleep.new_internal_jobs(1, queue_was_empty);
         .              }
         .          
         .              #[inline]
         .              pub(super) unsafe fn push_fifo(&self, job: JobRef) {
         .                  self.push(self.fifo.push(job));
         .              }
         .          
         .              #[inline]
-- line 732 ----------------------------------------
-- line 734 ----------------------------------------
         .                  self.worker.is_empty()
         .              }
         .          
         .              /// Attempts to obtain a "local" job -- typically this means
         .              /// popping from the top of the stack, though if we are configured
         .              /// for breadth-first execution, it would mean dequeuing from the
         .              /// bottom.
         .              #[inline]
    82,740  (0.1%)      pub(super) fn take_local_job(&self) -> Option<JobRef> {
         .                  let popped_job = self.worker.pop();
         .          
         .                  if popped_job.is_some() {
         .                      return popped_job;
         .                  }
         .          
         .                  loop {
   132,684  (0.1%)              match self.stealer.steal() {
         .                          Steal::Success(job) => return Some(job),
         .                          Steal::Empty => return None,
         .                          Steal::Retry => {}
         .                      }
         .                  }
   115,836  (0.1%)      }
         .          
         .              fn has_injected_job(&self) -> bool {
       423  (0.0%)          !self.stealer.is_empty() || self.registry.has_injected_job()
         .              }
         .          
         .              /// Wait until the latch is set. Try to keep busy by popping and
         .              /// stealing tasks as necessary.
         .              #[inline]
         .              pub(super) unsafe fn wait_until<L: AsCoreLatch + ?Sized>(&self, latch: &L) {
         .                  let latch = latch.as_core_latch();
        75  (0.0%)          if !latch.probe() {
       150  (0.0%)              self.wait_until_cold(latch);
         .                  }
         .              }
         .          
         .              #[cold]
     6,111  (0.0%)      unsafe fn wait_until_cold(&self, latch: &CoreLatch) {
         .                  // the code below should swallow all panics and hence never
         .                  // unwind; but if something does wrong, we want to abort,
         .                  // because otherwise other code in rayon may assume that the
         .                  // latch has been signaled, and that can lead to random memory
         .                  // accesses, which would be *very bad*
         .                  let abort_guard = unwind::AbortIfPanic;
         .          
    -5,676 (-0.0%)          'outer: while !latch.probe() {
         .                      // Check for local work *before* we start marking ourself idle,
         .                      // especially to avoid modifying shared sleep state.
       579  (0.0%)              if let Some(job) = self.take_local_job() {
         .                          self.execute(job);
         .                          continue;
         .                      }
         .          
       193  (0.0%)              let mut idle_state = self.registry.sleep.start_looking(self.index);
    14,854  (0.0%)              while !latch.probe() {
 1,172,810  (1.1%)                  if let Some(job) = self.find_work() {
    -3,914 (-0.0%)                      self.registry.sleep.work_found();
         .                              self.execute(job);
         .                              // The job might have injected local work, so go back to the outer loop.
         .                              continue 'outer;
         .                          } else {
    16,216  (0.0%)                      self.registry
         .                                  .sleep
         .                                  .no_work_found(&mut idle_state, latch, || self.has_injected_job())
         .                          }
         .                      }
         .          
         .                      // If we were sleepy, we are not anymore. We "found work" --
         .                      // whatever the surrounding thread was doing before it had to wait.
    -1,555 (-0.0%)              self.registry.sleep.work_found();
         .                      break;
         .                  }
         .          
         .                  mem::forget(abort_guard); // successful execution, do not abort
       600  (0.0%)      }
         .          
         .              unsafe fn wait_until_out_of_work(&self) {
         .                  debug_assert_eq!(self as *const _, WorkerThread::current());
         .                  let registry = &*self.registry;
         0                  let index = self.index;
         .          
         0                  self.wait_until(&registry.thread_infos[index].terminate);
         .          
         .                  // Should not be any work left in our queue.
         .                  debug_assert!(self.take_local_job().is_none());
         .          
         .                  // Let registry know we are done
         .                  Latch::set(&registry.thread_infos[index].stopped);
         .              }
         .          
         .              fn find_work(&self) -> Option<JobRef> {
         .                  // Try to find some work to do. We give preference first
         .                  // to things in our local deque, then in other workers
         .                  // deques, and finally to injected jobs from the
         .                  // outside. The idea is to finish what we started before
         .                  // we take on something new.
    16,355  (0.0%)          self.take_local_job()
         .                      .or_else(|| self.steal())
         .                      .or_else(|| self.registry.pop_injected_job())
         .              }
         .          
         .              pub(super) fn yield_now(&self) -> Yield {
         .                  match self.find_work() {
         .                      Some(job) => unsafe {
         .                          self.execute(job);
-- line 840 ----------------------------------------
-- line 865 ----------------------------------------
         .              /// local work to do.
         .              fn steal(&self) -> Option<JobRef> {
         .                  // we only steal when we don't have any work to do locally
         .                  debug_assert!(self.local_deque_is_empty());
         .          
         .                  // otherwise, try to steal
         .                  let thread_infos = &self.registry.thread_infos.as_slice();
         .                  let num_threads = thread_infos.len();
    32,710  (0.0%)          if num_threads <= 1 {
         .                      return None;
         .                  }
         .          
         .                  loop {
         .                      let mut retry = false;
         .                      let start = self.rng.next_usize(num_threads);
         .                      let job = (start..num_threads)
         .                          .chain(0..start)
   325,674  (0.3%)                  .filter(move |&i| i != self.index)
         .                          .find_map(|victim_index| {
   776,916  (0.7%)                      let victim = &thread_infos[victim_index];
 1,222,798  (1.1%)                      match victim.stealer.steal() {
       366  (0.0%)                          Steal::Success(job) => Some(job),
         .                                  Steal::Empty => None,
         .                                  Steal::Retry => {
         .                                      retry = true;
         .                                      None
         .                                  }
         .                              }
         .                          });
-1,117,047 (-1.0%)              if job.is_some() || !retry {
         .                          return job;
         .                      }
         .                  }
         .              }
         .          }
         .          
         .          /// ////////////////////////////////////////////////////////////////////////
         .          
         .          unsafe fn main_loop(thread: ThreadBuilder) {
         0              let worker_thread = &WorkerThread::from(thread);
         .              WorkerThread::set_current(worker_thread);
         .              let registry = &*worker_thread.registry;
         0              let index = worker_thread.index;
         .          
         .              // let registry know we are ready to do work
         0              Latch::set(&registry.thread_infos[index].primed);
         .          
         .              // Worker threads should not panic. If they do, just abort, as the
         .              // internal state of the threadpool is corrupted. Note that if
         .              // **user code** panics, we should catch that and redirect.
         .              let abort_guard = unwind::AbortIfPanic;
         .          
         .              // Inform a user callback that we started a thread.
         0              if let Some(ref handler) = registry.start_handler {
         .                  registry.catch_unwind(|| handler(index));
         .              }
         .          
         .              worker_thread.wait_until_out_of_work();
         .          
         .              // Normal termination, do not abort.
         .              mem::forget(abort_guard);
         .          
-- line 926 ----------------------------------------
-- line 938 ----------------------------------------
         .          /// `true` if injection was performed, `false` if executed directly.
         .          pub(super) fn in_worker<OP, R>(op: OP) -> R
         .          where
         .              OP: FnOnce(&WorkerThread, bool) -> R + Send,
         .              R: Send,
         .          {
         .              unsafe {
         .                  let owner_thread = WorkerThread::current();
    36,482  (0.0%)          if !owner_thread.is_null() {
         .                      // Perfectly valid to give them a `&T`: this is the
         .                      // current thread, so we know the data structure won't be
         .                      // invalidated until we return.
         .                      op(&*owner_thread, false)
         .                  } else {
       135  (0.0%)              global_registry().in_worker(op)
         .                  }
         .              }
         .          }
         .          
         .          /// [xorshift*] is a fast pseudorandom number generator which will
         .          /// even tolerate weak seeding, as long as it's not zero.
         .          ///
         .          /// [xorshift*]: https://en.wikipedia.org/wiki/Xorshift#xorshift*
-- line 960 ----------------------------------------
-- line 961 ----------------------------------------
         .          struct XorShift64Star {
         .              state: Cell<u64>,
         .          }
         .          
         .          impl XorShift64Star {
         .              fn new() -> Self {
         .                  // Any non-zero seed will do -- this uses the hash of a global counter.
         .                  let mut seed = 0;
         0                  while seed == 0 {
         .                      let mut hasher = DefaultHasher::new();
         .                      static COUNTER: AtomicUsize = AtomicUsize::new(0);
         .                      hasher.write_usize(COUNTER.fetch_add(1, Ordering::Relaxed));
         .                      seed = hasher.finish();
         .                  }
         .          
         .                  XorShift64Star {
         .                      state: Cell::new(seed),
         .                  }
         .              }
         .          
         .              fn next(&self) -> u64 {
         .                  let mut x = self.state.get();
         .                  debug_assert_ne!(x, 0);
    49,062  (0.0%)          x ^= x >> 12;
    49,062  (0.0%)          x ^= x << 25;
    49,062  (0.0%)          x ^= x >> 27;
         .                  self.state.set(x);
         .                  x.wrapping_mul(0x2545_f491_4f6c_dd1d)
         .              }
         .          
         .              /// Return a value from `0..n`.
         .              fn next_usize(&self, n: usize) -> usize {
   114,478  (0.1%)          (self.next() % n as u64) as usize
         .              }
         .          }

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/sleep/counters.rs
--------------------------------------------------------------------------------
Ir____________ 

586,405 (0.5%)  <unknown (line 0)>

-- line 18 ----------------------------------------
      .         #[derive(Copy, Clone)]
      .         pub(super) struct Counters {
      .             word: usize,
      .         }
      .         
      .         /// A value read from the **Jobs Event Counter**.
      .         /// See the [`README.md`](README.md) for more
      .         /// coverage of how the jobs event counter works.
    413 (0.0%)  #[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
      .         pub(super) struct JobsEventCounter(usize);
      .         
      .         impl JobsEventCounter {
      .             pub(super) const DUMMY: JobsEventCounter = JobsEventCounter(std::usize::MAX);
      .         
      .             #[inline]
      .             pub(super) fn as_usize(self) -> usize {
      .                 self.0
-- line 34 ----------------------------------------
-- line 35 ----------------------------------------
      .             }
      .         
      .             /// The JEC "is sleepy" if the last thread to increment it was in the
      .             /// process of becoming sleepy. This is indicated by its value being *even*.
      .             /// When new jobs are posted, they check if the JEC is sleepy, and if so
      .             /// they incremented it.
      .             #[inline]
      .             pub(super) fn is_sleepy(self) -> bool {
    408 (0.0%)          (self.as_usize() & 1) == 0
      .             }
      .         
      .             /// The JEC "is active" if the last thread to increment it was posting new
      .             /// work. This is indicated by its value being *odd*. When threads get
      .             /// sleepy, they will check if the JEC is active, and increment it.
      .             #[inline]
      .             pub(super) fn is_active(self) -> bool {
      .                 !self.is_sleepy()
-- line 51 ----------------------------------------
-- line 126 ----------------------------------------
      .             /// odd (active) or vice versa. Returns the final value of the counters, for
      .             /// which `increment_when` is guaranteed to return false.
      .             pub(super) fn increment_jobs_event_counter_if(
      .                 &self,
      .                 increment_when: impl Fn(JobsEventCounter) -> bool,
      .             ) -> Counters {
      .                 loop {
      .                     let old_value = self.load(Ordering::SeqCst);
    408 (0.0%)              if increment_when(old_value.jobs_counter()) {
      .                         let new_value = old_value.increment_jobs_counter();
    176 (0.0%)                  if self.try_exchange(old_value, new_value, Ordering::SeqCst) {
      .                             return new_value;
      .                         }
      .                     } else {
      .                         return old_value;
      .                     }
      .                 }
      .             }
      .         
-- line 144 ----------------------------------------
-- line 199 ----------------------------------------
      .                 );
      .                 debug_assert!(
      .                     old_value.sleeping_threads() < THREADS_MAX,
      .                     "try_add_sleeping_thread: old_value {:?} has too many sleeping threads",
      .                     old_value,
      .                 );
      .         
      .                 let mut new_value = old_value;
    423 (0.0%)          new_value.word += ONE_SLEEPING;
      .         
      .                 self.try_exchange(old_value, new_value, Ordering::SeqCst)
      .             }
      .         }
      .         
      .         #[inline]
      .         fn select_thread(word: usize, shift: usize) -> usize {
    432 (0.0%)      (word >> shift) & THREADS_MAX
      .         }
      .         
      .         #[inline]
      .         fn select_jec(word: usize) -> usize {
  1,234 (0.0%)      word >> JEC_SHIFT
      .         }
      .         
      .         impl Counters {
      .             #[inline]
      .             fn new(word: usize) -> Counters {
      .                 Counters { word }
      .             }
      .         
-- line 228 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rayon-core-1.12.0/src/sleep/mod.rs
--------------------------------------------------------------------------------
Ir______________ 

 491,664  (0.5%)  <unknown (line 0)>

-- line 40 ----------------------------------------
       .              rounds: u32,
       .          
       .              /// Once we become sleepy, what was the sleepy counter value?
       .              /// Set to `INVALID_SLEEPY_COUNTER` otherwise.
       .              jobs_counter: JobsEventCounter,
       .          }
       .          
       .          /// The "sleep state" for an individual worker.
      -9 (-0.0%)  #[derive(Default)]
       .          struct WorkerSleepState {
       .              /// Set to true when the worker goes to sleep; set to false when
       .              /// the worker is notified or when it wakes.
       .              is_blocked: Mutex<bool>,
       .          
       .              condvar: Condvar,
       .          }
       .          
-- line 56 ----------------------------------------
-- line 65 ----------------------------------------
       .                      counters: AtomicCounters::new(),
       .                  }
       .              }
       .          
       .              #[inline]
       .              pub(super) fn start_looking(&self, worker_index: usize) -> IdleState {
       .                  self.counters.add_inactive_thread();
       .          
   6,261  (0.0%)          IdleState {
       .                      worker_index,
       .                      rounds: 0,
       .                      jobs_counter: JobsEventCounter::DUMMY,
       .                  }
       .              }
       .          
       .              #[inline]
       .              pub(super) fn work_found(&self) {
       .                  // If we were the last idle thread and other threads are still sleeping,
       .                  // then we should wake up another thread.
       .                  let threads_to_wake = self.counters.sub_inactive_thread();
     193  (0.0%)          self.wake_any_threads(threads_to_wake as u32);
       .              }
       .          
       .              #[inline]
       .              pub(super) fn no_work_found(
       .                  &self,
       .                  idle_state: &mut IdleState,
       .                  latch: &CoreLatch,
       .                  has_injected_jobs: impl FnOnce() -> bool,
       .              ) {
  48,648  (0.0%)          if idle_state.rounds < ROUNDS_UNTIL_SLEEPY {
       .                      thread::yield_now();
-502,686 (-0.5%)              idle_state.rounds += 1;
     821  (0.0%)          } else if idle_state.rounds == ROUNDS_UNTIL_SLEEPY {
     408  (0.0%)              idle_state.jobs_counter = self.announce_sleepy();
     408  (0.0%)              idle_state.rounds += 1;
       .                      thread::yield_now();
       .                  } else if idle_state.rounds < ROUNDS_UNTIL_SLEEPING {
       .                      idle_state.rounds += 1;
       .                      thread::yield_now();
       .                  } else {
       .                      debug_assert_eq!(idle_state.rounds, ROUNDS_UNTIL_SLEEPING);
  34,697  (0.0%)              self.sleep(idle_state, latch, has_injected_jobs);
       .                  }
       .              }
       .          
       .              #[cold]
       .              fn announce_sleepy(&self) -> JobsEventCounter {
       .                  self.counters
       .                      .increment_jobs_event_counter_if(JobsEventCounter::is_active)
       .                      .jobs_counter()
       .              }
       .          
       .              #[cold]
   3,717  (0.0%)      fn sleep(
       .                  &self,
       .                  idle_state: &mut IdleState,
       .                  latch: &CoreLatch,
       .                  has_injected_jobs: impl FnOnce() -> bool,
       .              ) {
     413  (0.0%)          let worker_index = idle_state.worker_index;
       .          
     413  (0.0%)          if !latch.get_sleepy() {
       .                      return;
       .                  }
       .          
     826  (0.0%)          let sleep_state = &self.worker_sleep_states[worker_index];
       .                  let mut is_blocked = sleep_state.is_blocked.lock().unwrap();
       .                  debug_assert!(!*is_blocked);
       .          
       .                  // Our latch was signalled. We should wake back up fully as we
       .                  // will have some stuff to do.
 -15,903 (-0.0%)          if !latch.fall_asleep() {
       .                      idle_state.wake_fully();
       .                      return;
       .                  }
       .          
       .                  loop {
       .                      let counters = self.counters.load(Ordering::SeqCst);
       .          
       .                      // Check if the JEC has changed since we got sleepy.
       .                      debug_assert!(idle_state.jobs_counter.is_sleepy());
     413  (0.0%)              if counters.jobs_counter() != idle_state.jobs_counter {
       .                          // JEC has changed, so a new job was posted, but for some reason
       .                          // we didn't see it. We should return to just before the SLEEPY
       .                          // state so we can do another search and (if we fail to find
       .                          // work) go back to sleep.
       .                          idle_state.wake_partly();
       .                          latch.wake_up();
       .                          return;
       .                      }
       .          
       .                      // Otherwise, let's move from IDLE to SLEEPING.
     423  (0.0%)              if self.counters.try_add_sleeping_thread(counters) {
       .                          break;
       .                      }
       .                  }
       .          
       .                  // Successfully registered as asleep.
       .          
       .                  // We have one last check for injected jobs to do. This protects against
       .                  // deadlock in the very unlikely event that
       .                  //
       .                  // - an external job is being injected while we are sleepy
       .                  // - that job triggers the rollover over the JEC such that we don't see it
       .                  // - we are the last active worker thread
       .                  std::sync::atomic::fence(Ordering::SeqCst);
     423  (0.0%)          if has_injected_jobs() {
       .                      // If we see an externally injected job, then we have to 'wake
       .                      // ourselves up'. (Ordinarily, `sub_sleeping_thread` is invoked by
       .                      // the one that wakes us.)
       .                      self.counters.sub_sleeping_thread();
       .                  } else {
       .                      // If we don't see an injected job (the normal case), then flag
       .                      // ourselves as asleep and wait till we are notified.
       .                      //
       .                      // (Note that `is_blocked` is held under a mutex and the mutex was
       .                      // acquired *before* we incremented the "sleepy counter". This means
       .                      // that whomever is coming to wake us will have to wait until we
       .                      // release the mutex in the call to `wait`, so they will see this
       .                      // boolean as true.)
     846  (0.0%)              *is_blocked = true;
   3,379  (0.0%)              while *is_blocked {
     846  (0.0%)                  is_blocked = sleep_state.condvar.wait(is_blocked).unwrap();
       .                      }
       .                  }
       .          
       .                  // Update other state:
       .                  idle_state.wake_fully();
       .                  latch.wake_up();
-127,704 (-0.1%)      }
       .          
       .              /// Notify the given thread that it should wake up (if it is
       .              /// sleeping).  When this method is invoked, we typically know the
       .              /// thread is asleep, though in rare cases it could have been
       .              /// awoken by (e.g.) new work having been posted.
       .              pub(super) fn notify_worker_latch_is_set(&self, target_worker_index: usize) {
      54  (0.0%)          self.wake_specific_thread(target_worker_index);
       .              }
       .          
       .              /// Signals that `num_jobs` new jobs were injected into the thread
       .              /// pool from outside. This function will ensure that there are
       .              /// threads available to process them, waking threads from sleep
       .              /// if necessary.
       .              ///
       .              /// # Parameters
-- line 210 ----------------------------------------
-- line 245 ----------------------------------------
       .                  // -- announce that there is now work available. The final value of `counters`
       .                  // with which we exit the loop thus corresponds to a state when
       .                  let counters = self
       .                      .counters
       .                      .increment_jobs_event_counter_if(JobsEventCounter::is_sleepy);
       .                  let num_awake_but_idle = counters.awake_but_idle_threads();
       .                  let num_sleepers = counters.sleeping_threads();
       .          
     -14 (-0.0%)          if num_sleepers == 0 {
       .                      // nobody to wake
       .                      return;
       .                  }
       .          
       .                  // Promote from u16 to u32 so we can interoperate with
       .                  // num_jobs more easily.
       .                  let num_awake_but_idle = num_awake_but_idle as u32;
       .                  let num_sleepers = num_sleepers as u32;
       .          
       .                  // If the queue is non-empty, then we always wake up a worker
       .                  // -- clearly the existing idle jobs aren't enough. Otherwise,
       .                  // check to see if we have enough idle workers.
     239  (0.0%)          if !queue_was_empty {
       .                      let num_to_wake = std::cmp::min(num_jobs, num_sleepers);
       .                      self.wake_any_threads(num_to_wake);
     478  (0.0%)          } else if num_awake_but_idle < num_jobs {
       .                      let num_to_wake = std::cmp::min(num_jobs - num_awake_but_idle, num_sleepers);
       .                      self.wake_any_threads(num_to_wake);
       .                  }
       .              }
       .          
       .              #[cold]
 -55,865 (-0.1%)      fn wake_any_threads(&self, mut num_to_wake: u32) {
  68,756  (0.1%)          if num_to_wake > 0 {
       .                      for i in 0..self.worker_sleep_states.len() {
  22,385  (0.0%)                  if self.wake_specific_thread(i) {
       .                              num_to_wake -= 1;
  13,431  (0.0%)                      if num_to_wake == 0 {
       .                                  return;
       .                              }
       .                          }
       .                      }
       .                  }
 -55,555 (-0.1%)      }
       .          
  22,655  (0.0%)      fn wake_specific_thread(&self, index: usize) -> bool {
   9,062  (0.0%)          let sleep_state = &self.worker_sleep_states[index];
       .          
       .                  let mut is_blocked = sleep_state.is_blocked.lock().unwrap();
  13,593  (0.0%)          if *is_blocked {
     423  (0.0%)              *is_blocked = false;
     423  (0.0%)              sleep_state.condvar.notify_one();
       .          
       .                      // When the thread went to sleep, it will have incremented
       .                      // this value. When we wake it, its our job to decrement
       .                      // it. We could have the thread do it, but that would
       .                      // introduce a delay between when the thread was
       .                      // *notified* and when this counter was decremented. That
       .                      // might mislead people with new work into thinking that
       .                      // there are sleeping threads that they should try to
-- line 303 ----------------------------------------
-- line 304 ----------------------------------------
       .                      // wake, when in fact there is nothing left for them to
       .                      // do.
       .                      self.counters.sub_sleeping_thread();
       .          
       .                      true
       .                  } else {
       .                      false
       .                  }
  31,717  (0.0%)      }
       .          }
       .          
       .          impl IdleState {
       .              fn wake_fully(&mut self) {
     422  (0.0%)          self.rounds = 0;
  16,644  (0.0%)          self.jobs_counter = JobsEventCounter::DUMMY;
       .              }
       .          
       .              fn wake_partly(&mut self) {
     -10 (-0.0%)          self.rounds = ROUNDS_UNTIL_SLEEPY;
      66  (0.0%)          self.jobs_counter = JobsEventCounter::DUMMY;
       .              }
       .          }

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-7984a0b3eeacb87c/out/zip.rs
--------------------------------------------------------------------------------
Ir______________ 

-783,989 (-0.7%)  <unknown (line 0)>

-- line 11 ----------------------------------------
       .          }
       .          
       .          impl <M0: for<'short> Mat<'short>,> Zip<(M0,)> {
       .              #[inline(always)]
       .              pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,)) {
       .                  let mut this = self;
       .                  let mut op = op;
       .          
  -6,272 (-0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
       .                      this.tuple.0 = this.tuple.0.transpose();
       .                  }
 -12,544 (-0.0%)          if this.tuple.0.row_stride() < 0 {
       .                      this.tuple.0 = this.tuple.0.reverse_rows();
       .                  }
       .          
       .                  let nrows = this.tuple.0.nrows();
       .                  let ncols = this.tuple.0.ncols();
       .          
       .                  unsafe {
 -12,544 (-0.0%)              if this.tuple.0.row_stride() == 1 {
       .                          let start = 0;
       .                          let len = nrows;
       .                          for j in 0..ncols {
       .                              let slice0 = this.tuple.0.get_column_slice(start, j, len);
       .          
       .                              contiguous_impl1(nrows, &mut op, slice0,);
       .                          }
       .                      } else {
-- line 38 ----------------------------------------
-- line 112 ----------------------------------------
       .                  this.for_each_triangular_lower(diag, op);
       .              }
       .          
       .              #[inline]
       .              #[track_caller]
       .              pub fn zip_unchecked<M1: for<'short> Mat<'short>>(self, last: M1) -> Zip<(M0, M1)> {
       .                  let this = self;
       .                  debug_assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
    -132 (-0.0%)          Zip { tuple: (this.tuple.0, last) }
       .              }
       .              #[inline]
       .              #[track_caller]
       .              pub fn zip<M1: for<'short> Mat<'short>>(self, last: M1) -> Zip<(M0, M1)> {
       .                  let this = self;
  -8,328 (-0.0%)          assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
  -4,162 (-0.0%)          Zip { tuple: (this.tuple.0, last) }
       .              }
       .          }
       .          
       .          #[inline(always)]
       .          unsafe fn contiguous_impl2<M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,>(
       .              len: usize,
       .              op: &mut impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,),
       .              mut slice0: <M0 as Mat<'_>>::RawSlice,mut slice1: <M1 as Mat<'_>>::RawSlice,
-- line 135 ----------------------------------------
-- line 140 ----------------------------------------
       .          }
       .          
       .          impl <M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,> Zip<(M0,M1,)> {
       .              #[inline(always)]
       .              pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,)) {
       .                  let mut this = self;
       .                  let mut op = op;
       .          
    -132 (-0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
       .                      this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();
       .                  }
    -132 (-0.0%)          if this.tuple.0.row_stride() < 0 {
       .                      this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();
       .                  }
       .          
       .                  let nrows = this.tuple.0.nrows();
       .                  let ncols = this.tuple.0.ncols();
       .          
       .                  unsafe {
    -132 (-0.0%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1 {
       .                          let start = 0;
       .                          let len = nrows;
       .                          for j in 0..ncols {
       .                              let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);
       .          
       .                              contiguous_impl2(nrows, &mut op, slice0,slice1,);
       .                          }
       .                      } else {
-- line 167 ----------------------------------------
-- line 182 ----------------------------------------
       .                  };
       .          
       .                  let mut this = self;
       .                  let mut op = op;
       .          
       .                  let mut transpose = false;
       .                  let mut reverse_rows = false;
       .          
  -8,326 (-0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
       .                      this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();
       .                      transpose = true;
       .                  }
 -31,689 (-0.0%)          if this.tuple.0.row_stride() < 0 {
       .                      this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();
       .                      reverse_rows = true;
       .                  }
       .          
       .                  let nrows = this.tuple.0.nrows();
       .                  let ncols = this.tuple.0.ncols();
       .          
       .                  let ncols = if transpose { ncols } else { ncols.min(nrows) };
       .          
       .                  unsafe {
 -10,405 (-0.0%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1 {
       .                          for j in 0..ncols {
-167,243 (-0.2%)                      let (start, end) = match (transpose, reverse_rows) {
       .                                  (false, false) => (j + strict as usize, nrows),
       .                                  (false, true) => (0, (nrows - (j + strict as usize))),
       .                                  (true, false) => (0, (j + !strict as usize).min(nrows)),
       .                                  (true, true) => (nrows - ((j + !strict as usize).min(nrows)), nrows),
       .                              };
       .          
      -2 (-0.0%)                      let len = end - start;
       .          
       .                              let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);
       .          
       .                              contiguous_impl2(len, &mut op, slice0,slice1,);
       .                          }
       .                      } else {
       .                          for j in 0..ncols {
       .                              let (start, end) = match (transpose, reverse_rows) {
-- line 222 ----------------------------------------
-- line 241 ----------------------------------------
       .                  this.for_each_triangular_lower(diag, op);
       .              }
       .          
       .              #[inline]
       .              #[track_caller]
       .              pub fn zip_unchecked<M2: for<'short> Mat<'short>>(self, last: M2) -> Zip<(M0,M1, M2)> {
       .                  let this = self;
       .                  debug_assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
    -644 (-0.0%)          Zip { tuple: (this.tuple.0,this.tuple.1, last) }
       .              }
       .              #[inline]
       .              #[track_caller]
       .              pub fn zip<M2: for<'short> Mat<'short>>(self, last: M2) -> Zip<(M0,M1, M2)> {
       .                  let this = self;
       .                  assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
       .                  Zip { tuple: (this.tuple.0,this.tuple.1, last) }
       .              }
-- line 257 ----------------------------------------
-- line 269 ----------------------------------------
       .          }
       .          
       .          impl <M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,M2: for<'short> Mat<'short>,> Zip<(M0,M1,M2,)> {
       .              #[inline(always)]
       .              pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,<M2 as Mat<'_>>::Item,)) {
       .                  let mut this = self;
       .                  let mut op = op;
       .          
    -322 (-0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
       .                      this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();this.tuple.2 = this.tuple.2.transpose();
       .                  }
    -322 (-0.0%)          if this.tuple.0.row_stride() < 0 {
       .                      this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();this.tuple.2 = this.tuple.2.reverse_rows();
       .                  }
       .          
       .                  let nrows = this.tuple.0.nrows();
       .                  let ncols = this.tuple.0.ncols();
       .          
       .                  unsafe {
    -322 (-0.0%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1&&this.tuple.2.row_stride() == 1 {
       .                          let start = 0;
       .                          let len = nrows;
       .                          for j in 0..ncols {
       .                              let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);let slice2 = this.tuple.2.get_column_slice(start, j, len);
       .          
       .                              contiguous_impl3(nrows, &mut op, slice0,slice1,slice2,);
       .                          }
       .                      } else {
-- line 296 ----------------------------------------
-- line 370 ----------------------------------------
       .                  this.for_each_triangular_lower(diag, op);
       .              }
       .          
       .              #[inline]
       .              #[track_caller]
       .              pub fn zip_unchecked<M3: for<'short> Mat<'short>>(self, last: M3) -> Zip<(M0,M1,M2, M3)> {
       .                  let this = self;
       .                  debug_assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
-580,146 (-0.5%)          Zip { tuple: (this.tuple.0,this.tuple.1,this.tuple.2, last) }
       .              }
       .              #[inline]
       .              #[track_caller]
       .              pub fn zip<M3: for<'short> Mat<'short>>(self, last: M3) -> Zip<(M0,M1,M2, M3)> {
       .                  let this = self;
       .                  assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
       .                  Zip { tuple: (this.tuple.0,this.tuple.1,this.tuple.2, last) }
       .              }
-- line 386 ----------------------------------------
-- line 398 ----------------------------------------
       .          }
       .          
       .          impl <M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,M2: for<'short> Mat<'short>,M3: for<'short> Mat<'short>,> Zip<(M0,M1,M2,M3,)> {
       .              #[inline(always)]
       .              pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,<M2 as Mat<'_>>::Item,<M3 as Mat<'_>>::Item,)) {
       .                  let mut this = self;
       .                  let mut op = op;
       .          
-193,382 (-0.2%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
       .                      this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();this.tuple.2 = this.tuple.2.transpose();this.tuple.3 = this.tuple.3.transpose();
       .                  }
-193,382 (-0.2%)          if this.tuple.0.row_stride() < 0 {
       .                      this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();this.tuple.2 = this.tuple.2.reverse_rows();this.tuple.3 = this.tuple.3.reverse_rows();
       .                  }
       .          
       .                  let nrows = this.tuple.0.nrows();
       .                  let ncols = this.tuple.0.ncols();
       .          
       .                  unsafe {
-193,382 (-0.2%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1&&this.tuple.2.row_stride() == 1&&this.tuple.3.row_stride() == 1 {
       .                          let start = 0;
       .                          let len = nrows;
       .                          for j in 0..ncols {
       .                              let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);let slice2 = this.tuple.2.get_column_slice(start, j, len);let slice3 = this.tuple.3.get_column_slice(start, j, len);
       .          
       .                              contiguous_impl4(nrows, &mut op, slice0,slice1,slice2,slice3,);
       .                          }
       .                      } else {
-- line 425 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/kirpal/Documents/rust/gauss/target/release/build/faer-core-9690d53cf423d055/out/zip.rs
--------------------------------------------------------------------------------
Ir____________ 

633,411 (0.6%)  <unknown (line 0)>

-- line 11 ----------------------------------------
      .         }
      .         
      .         impl <M0: for<'short> Mat<'short>,> Zip<(M0,)> {
      .             #[inline(always)]
      .             pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,)) {
      .                 let mut this = self;
      .                 let mut op = op;
      .         
  6,272 (0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
      .                     this.tuple.0 = this.tuple.0.transpose();
      .                 }
 12,544 (0.0%)          if this.tuple.0.row_stride() < 0 {
      .                     this.tuple.0 = this.tuple.0.reverse_rows();
      .                 }
      .         
      .                 let nrows = this.tuple.0.nrows();
      .                 let ncols = this.tuple.0.ncols();
      .         
      .                 unsafe {
 12,544 (0.0%)              if this.tuple.0.row_stride() == 1 {
      .                         let start = 0;
      .                         let len = nrows;
      .                         for j in 0..ncols {
      .                             let slice0 = this.tuple.0.get_column_slice(start, j, len);
      .         
      .                             contiguous_impl1(nrows, &mut op, slice0,);
      .                         }
      .                     } else {
-- line 38 ----------------------------------------
-- line 112 ----------------------------------------
      .                 this.for_each_triangular_lower(diag, op);
      .             }
      .         
      .             #[inline]
      .             #[track_caller]
      .             pub fn zip_unchecked<M1: for<'short> Mat<'short>>(self, last: M1) -> Zip<(M0, M1)> {
      .                 let this = self;
      .                 debug_assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
    132 (0.0%)          Zip { tuple: (this.tuple.0, last) }
      .             }
      .             #[inline]
      .             #[track_caller]
      .             pub fn zip<M1: for<'short> Mat<'short>>(self, last: M1) -> Zip<(M0, M1)> {
      .                 let this = self;
  8,328 (0.0%)          assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
  4,162 (0.0%)          Zip { tuple: (this.tuple.0, last) }
      .             }
      .         }
      .         
      .         #[inline(always)]
      .         unsafe fn contiguous_impl2<M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,>(
      .             len: usize,
      .             op: &mut impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,),
      .             mut slice0: <M0 as Mat<'_>>::RawSlice,mut slice1: <M1 as Mat<'_>>::RawSlice,
-- line 135 ----------------------------------------
-- line 140 ----------------------------------------
      .         }
      .         
      .         impl <M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,> Zip<(M0,M1,)> {
      .             #[inline(always)]
      .             pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,)) {
      .                 let mut this = self;
      .                 let mut op = op;
      .         
    132 (0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
      .                     this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();
      .                 }
    132 (0.0%)          if this.tuple.0.row_stride() < 0 {
      .                     this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();
      .                 }
      .         
      .                 let nrows = this.tuple.0.nrows();
      .                 let ncols = this.tuple.0.ncols();
      .         
      .                 unsafe {
    132 (0.0%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1 {
      .                         let start = 0;
      .                         let len = nrows;
      .                         for j in 0..ncols {
      .                             let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);
      .         
      .                             contiguous_impl2(nrows, &mut op, slice0,slice1,);
      .                         }
      .                     } else {
-- line 167 ----------------------------------------
-- line 182 ----------------------------------------
      .                 };
      .         
      .                 let mut this = self;
      .                 let mut op = op;
      .         
      .                 let mut transpose = false;
      .                 let mut reverse_rows = false;
      .         
 31,691 (0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
      .                     this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();
      .                     transpose = true;
      .                 }
 33,770 (0.0%)          if this.tuple.0.row_stride() < 0 {
      .                     this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();
      .                     reverse_rows = true;
      .                 }
      .         
      .                 let nrows = this.tuple.0.nrows();
      .                 let ncols = this.tuple.0.ncols();
      .         
      .                 let ncols = if transpose { ncols } else { ncols.min(nrows) };
      .         
      .                 unsafe {
  8,324 (0.0%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1 {
      .                         for j in 0..ncols {
 55,054 (0.1%)                      let (start, end) = match (transpose, reverse_rows) {
 82,581 (0.1%)                          (false, false) => (j + strict as usize, nrows),
      .                                 (false, true) => (0, (nrows - (j + strict as usize))),
      .                                 (true, false) => (0, (j + !strict as usize).min(nrows)),
      .                                 (true, true) => (nrows - ((j + !strict as usize).min(nrows)), nrows),
      .                             };
      .         
      2 (0.0%)                      let len = end - start;
      .         
      .                             let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);
      .         
      .                             contiguous_impl2(len, &mut op, slice0,slice1,);
      .                         }
      .                     } else {
      .                         for j in 0..ncols {
      .                             let (start, end) = match (transpose, reverse_rows) {
-- line 222 ----------------------------------------
-- line 241 ----------------------------------------
      .                 this.for_each_triangular_lower(diag, op);
      .             }
      .         
      .             #[inline]
      .             #[track_caller]
      .             pub fn zip_unchecked<M2: for<'short> Mat<'short>>(self, last: M2) -> Zip<(M0,M1, M2)> {
      .                 let this = self;
      .                 debug_assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
    644 (0.0%)          Zip { tuple: (this.tuple.0,this.tuple.1, last) }
      .             }
      .             #[inline]
      .             #[track_caller]
      .             pub fn zip<M2: for<'short> Mat<'short>>(self, last: M2) -> Zip<(M0,M1, M2)> {
      .                 let this = self;
      .                 assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
      .                 Zip { tuple: (this.tuple.0,this.tuple.1, last) }
      .             }
-- line 257 ----------------------------------------
-- line 269 ----------------------------------------
      .         }
      .         
      .         impl <M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,M2: for<'short> Mat<'short>,> Zip<(M0,M1,M2,)> {
      .             #[inline(always)]
      .             pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,<M2 as Mat<'_>>::Item,)) {
      .                 let mut this = self;
      .                 let mut op = op;
      .         
    322 (0.0%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
      .                     this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();this.tuple.2 = this.tuple.2.transpose();
      .                 }
    322 (0.0%)          if this.tuple.0.row_stride() < 0 {
      .                     this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();this.tuple.2 = this.tuple.2.reverse_rows();
      .                 }
      .         
      .                 let nrows = this.tuple.0.nrows();
      .                 let ncols = this.tuple.0.ncols();
      .         
      .                 unsafe {
    322 (0.0%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1&&this.tuple.2.row_stride() == 1 {
      .                         let start = 0;
      .                         let len = nrows;
      .                         for j in 0..ncols {
      .                             let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);let slice2 = this.tuple.2.get_column_slice(start, j, len);
      .         
      .                             contiguous_impl3(nrows, &mut op, slice0,slice1,slice2,);
      .                         }
      .                     } else {
-- line 296 ----------------------------------------
-- line 370 ----------------------------------------
      .                 this.for_each_triangular_lower(diag, op);
      .             }
      .         
      .             #[inline]
      .             #[track_caller]
      .             pub fn zip_unchecked<M3: for<'short> Mat<'short>>(self, last: M3) -> Zip<(M0,M1,M2, M3)> {
      .                 let this = self;
      .                 debug_assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
580,146 (0.5%)          Zip { tuple: (this.tuple.0,this.tuple.1,this.tuple.2, last) }
      .             }
      .             #[inline]
      .             #[track_caller]
      .             pub fn zip<M3: for<'short> Mat<'short>>(self, last: M3) -> Zip<(M0,M1,M2, M3)> {
      .                 let this = self;
      .                 assert!((last.nrows(), last.ncols()) == (this.tuple.0.nrows(), this.tuple.0.ncols()));
      .                 Zip { tuple: (this.tuple.0,this.tuple.1,this.tuple.2, last) }
      .             }
-- line 386 ----------------------------------------
-- line 398 ----------------------------------------
      .         }
      .         
      .         impl <M0: for<'short> Mat<'short>,M1: for<'short> Mat<'short>,M2: for<'short> Mat<'short>,M3: for<'short> Mat<'short>,> Zip<(M0,M1,M2,M3,)> {
      .             #[inline(always)]
      .             pub fn for_each(self, op: impl FnMut(<M0 as Mat<'_>>::Item,<M1 as Mat<'_>>::Item,<M2 as Mat<'_>>::Item,<M3 as Mat<'_>>::Item,)) {
      .                 let mut this = self;
      .                 let mut op = op;
      .         
193,382 (0.2%)          if this.tuple.0.row_stride().unsigned_abs() > this.tuple.0.col_stride().unsigned_abs() {
      .                     this.tuple.0 = this.tuple.0.transpose();this.tuple.1 = this.tuple.1.transpose();this.tuple.2 = this.tuple.2.transpose();this.tuple.3 = this.tuple.3.transpose();
      .                 }
193,382 (0.2%)          if this.tuple.0.row_stride() < 0 {
      .                     this.tuple.0 = this.tuple.0.reverse_rows();this.tuple.1 = this.tuple.1.reverse_rows();this.tuple.2 = this.tuple.2.reverse_rows();this.tuple.3 = this.tuple.3.reverse_rows();
      .                 }
      .         
      .                 let nrows = this.tuple.0.nrows();
      .                 let ncols = this.tuple.0.ncols();
      .         
      .                 unsafe {
193,382 (0.2%)              if this.tuple.0.row_stride() == 1&&this.tuple.1.row_stride() == 1&&this.tuple.2.row_stride() == 1&&this.tuple.3.row_stride() == 1 {
      .                         let start = 0;
      .                         let len = nrows;
      .                         for j in 0..ncols {
      .                             let slice0 = this.tuple.0.get_column_slice(start, j, len);let slice1 = this.tuple.1.get_column_slice(start, j, len);let slice2 = this.tuple.2.get_column_slice(start, j, len);let slice3 = this.tuple.3.get_column_slice(start, j, len);
      .         
      .                             contiguous_impl4(nrows, &mut op, slice0,slice1,slice2,slice3,);
      .                         }
      .                     } else {
-- line 425 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/spec_from_iter_nested.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/alloc/src/vec/spec_from_iter_nested.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/array/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/array/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cell.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/cmp.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/intrinsics.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/intrinsics.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/filter.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/filter.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/zip.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/adapters/zip.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/range.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/traits/iterator.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/iter/traits/iterator.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/f64.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/f64.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/num/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/arith.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/function.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ops/function.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/option.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/const_ptr.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/metadata.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/metadata.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/mut_ptr.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/ptr/non_null.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/result.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/result.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/slice/index.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/slice/index.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/sync/atomic.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/tuple.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/core/src/tuple.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/f64.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/f64.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/panicking.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/panicking.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sync/poison.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sync/poison.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/common/thread_local/fast_local.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/common/thread_local/fast_local.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/alloc.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/alloc.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/futex.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/futex.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/locks/futex_mutex.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/locks/futex_mutex.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/thread.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/sys/unix/thread.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/thread/local.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/std/src/thread/local.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/stdarch/crates/std_detect/src/detect/cache.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/2e5a9dd6c9eaa42f0684b4b760bd68fc27cbe51b/library/stdarch/crates/std_detect/src/detect/cache.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/sync.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/sync.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/vec/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/alloc/src/vec/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/avx.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/fma.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/array/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/array/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cell.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cell.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/cmp.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/intrinsics.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/intrinsics.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/filter.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/filter.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/zip.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/adapters/zip.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/range.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/traits/iterator.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/iter/traits/iterator.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/f64.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/f64.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/num/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/arith.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/function.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ops/function.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/option.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/const_ptr.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/metadata.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/metadata.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/mut_ptr.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/ptr/non_null.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/result.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/result.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/slice/index.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/slice/index.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/sync/atomic.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/tuple.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/core/src/tuple.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/f64.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/f64.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/panicking.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/panicking.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sync/poison.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sync/poison.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/common/thread_local/fast_local.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/common/thread_local/fast_local.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/alloc.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/alloc.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/futex.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/futex.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/locks/futex_mutex.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/locks/futex_mutex.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/thread.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/sys/unix/thread.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/thread/local.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/std/src/thread/local.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/stdarch/crates/std_detect/src/detect/cache.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/d5c2e9c342b358556da91d61ed4133f6f50fc0c3/library/stdarch/crates/std_detect/src/detect/cache.rs

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir____________________ 

 584,586,010  (538.2%)    annotated: files known & above threshold & readable, line numbers known
 -48,907,321  (-45.0%)    annotated: files known & above threshold & readable, line numbers unknown
           0            unannotated: files known & above threshold & two or more non-identical
-427,496,277 (-393.6%)  unannotated: files known & above threshold & unreadable 
     433,305    (0.4%)  unannotated: files known & below threshold
          35    (0.0%)  unannotated: files unknown

