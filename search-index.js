var searchIndex = JSON.parse('{\
"gauss_lib":{"doc":"This library implements Gaussian processes (GP) for use in …","t":"NDINELLLLLLLLLLLLKLLLLLLLLLLLLLLLLKLLLLLLLLLL","n":["CholeskyFaiure","GaussProcs","Kernel","MismatchedInputs","ProcessError","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","deref","deref","deref_mut","deref_mut","deriv","drop","drop","dyn_smart_interpolate","eq","fmt","fmt","from","from","from","gradient","init","init","interpolate","into","into","log_marginal_likelihood","metric","new","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","update"],"q":[[0,"gauss_lib"],[45,"core::clone"],[46,"faer_core"],[47,"core::result"],[48,"core::fmt"],[49,"core::fmt"],[50,"alloc::vec"],[51,"core::any"]],"d":["cholesky decomposition failure","Creates a Gaussian Process Solver given a vector of …","Trait bounds needed for a type $\\\\text{T}$ to be a valid …","the input arrays are of different length","Error in the GP","","","","","","","","","","","","","The derivative of this covariance function — $\\\\phi’: …","","","Interpolate the process to a point, using only $n$ nearest …","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calculate the gradient of …","","","Interpolate the process to a series of points","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calculate the log marginal likelihood","The covariance function $\\\\phi$ on the type $\\\\text{T} — $ …","Creates a new Gaussian Process","","","","","","","","","Updates a new Gaussian Process"],"i":[1,0,0,1,0,1,2,1,2,1,2,1,2,1,2,1,2,3,1,2,2,1,1,2,1,1,2,2,1,2,2,1,2,2,3,2,1,2,1,2,1,2,1,2,2],"f":[0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[[[2,[-1]]],[[2,[-1]]],[3,4]],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],[6,-1,[]],[6,-1,[]],[6,-1,[]],[6,-1,[]],[[-1,-2,[8,[7]]],[[8,[7]]],[],[]],[6,5],[6,5],[[[2,[-1]],-1,6],[[10,[[5,[[9,[7]],[9,[7]]]],1]]],3],[[1,1],11],[[1,12],13],[[[2,[-1]],12],13,[3,14]],[15,1],[-1,-1,[]],[-1,-1,[]],[[[2,[-1]]],[[8,[7]]],3],[[],6],[[],6],[[[2,[-1]],[16,[-1]]],[[5,[[9,[7]],[9,[7]]]]],3],[-1,-2,[],[]],[-1,-2,[],[]],[[[2,[-1]]],7,3],[[-1,-2,[8,[7]]],7,[],[]],[[[17,[-1]],[17,[7]],7,[8,[7]]],[[10,[[2,[-1]],1]]],3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,18,[]],[-1,18,[]],[[[2,[-1]],-1,7],[[10,[5,1]]],3]],"c":[],"p":[[4,"ProcessError",0],[3,"GaussProcs",0],[8,"Kernel",0],[8,"Clone",45],[15,"tuple"],[15,"usize"],[15,"f64"],[15,"array"],[3,"Mat",46],[4,"Result",47],[15,"bool"],[3,"Formatter",48],[6,"Result",48],[8,"Debug",48],[3,"CholeskyError",49],[15,"slice"],[3,"Vec",50],[3,"TypeId",51]],"b":[]},\
"gauss_procs":{"doc":"","t":"DLLLLLLLLLLFFLFLLL","n":["TwoDpoint","borrow","borrow_mut","deref","deref_mut","deriv","drop","fmt","from","init","into","lim_nonpoly","main","metric","reconstruct_matrix","try_from","try_into","type_id"],"q":[[0,"gauss_procs"],[18,"core::fmt"],[19,"core::fmt"],[20,"faer_core"],[21,"core::any"]],"d":["","","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,0,0,2,0,2,2,2],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[1,-1,[]],[1,-1,[]],[[2,2,[4,[3]]],[[4,[3]]]],[1,5],[[2,6],7],[-1,-1,[]],[[],1],[-1,-2,[],[]],[2,3],[[],5],[[2,2,[4,[3]]],3],[[[8,[3]]],[[9,[3]]]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,11,[]]],"c":[],"p":[[15,"usize"],[3,"TwoDpoint",0],[15,"f64"],[15,"array"],[15,"tuple"],[3,"Formatter",18],[6,"Result",18],[3,"MatRef",19],[3,"Mat",19],[4,"Result",20],[3,"TypeId",21]],"b":[]},\
"rosenbrock":{"doc":"","t":"DLLLLLLLLFLLLLLLFLFFLLLLLLL","n":["TwoDpoint","borrow","borrow_mut","clone","clone_into","deref","deref_mut","deriv","drop","expected_improvement","fmt","from","from_subset","init","into","is_in_subset","main","metric","norm","rosenbrock","to_owned","to_subset","to_subset_unchecked","try_from","try_into","type_id","vzip"],"q":[[0,"rosenbrock"],[27,"core::fmt"],[28,"core::fmt"],[29,"core::result"],[30,"core::any"]],"d":["","","","","","","","","","Expected improement vs minimum given current min, EV and …","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","standard normal distribution (mean 0, std 1)","Rosenbrock function to test optimisation global minimum …","","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[[-1,-2],2,[],[]],[3,-1,[]],[3,-1,[]],[[1,1,[5,[4]]],[[5,[4]]]],[3,2],[[4,4,4,4],4],[[1,6],7],[-1,-1,[]],[-1,-2,[],[]],[[],3],[-1,-2,[],[]],[-1,8,[]],[[],2],[[1,1,[5,[4]]],4],[4,4],[1,4],[-1,-2,[],[]],[-1,[[9,[-2]]],[],[]],[-1,-2,[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,11,[]],[-1,-2,[],[]]],"c":[],"p":[[3,"TwoDpoint",0],[15,"tuple"],[15,"usize"],[15,"f64"],[15,"array"],[3,"Formatter",27],[6,"Result",27],[15,"bool"],[4,"Option",28],[4,"Result",29],[3,"TypeId",30]],"b":[]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
